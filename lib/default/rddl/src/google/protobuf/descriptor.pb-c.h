/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: google/protobuf/descriptor.proto */

#ifndef PROTOBUF_C_google_2fprotobuf_2fdescriptor_2eproto__INCLUDED
#define PROTOBUF_C_google_2fprotobuf_2fdescriptor_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1000000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1004001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct Google__Protobuf__FileDescriptorSet Google__Protobuf__FileDescriptorSet;
typedef struct Google__Protobuf__FileDescriptorProto Google__Protobuf__FileDescriptorProto;
typedef struct Google__Protobuf__DescriptorProto Google__Protobuf__DescriptorProto;
typedef struct Google__Protobuf__DescriptorProto__ExtensionRange Google__Protobuf__DescriptorProto__ExtensionRange;
typedef struct Google__Protobuf__DescriptorProto__ReservedRange Google__Protobuf__DescriptorProto__ReservedRange;
typedef struct Google__Protobuf__ExtensionRangeOptions Google__Protobuf__ExtensionRangeOptions;
typedef struct Google__Protobuf__FieldDescriptorProto Google__Protobuf__FieldDescriptorProto;
typedef struct Google__Protobuf__OneofDescriptorProto Google__Protobuf__OneofDescriptorProto;
typedef struct Google__Protobuf__EnumDescriptorProto Google__Protobuf__EnumDescriptorProto;
typedef struct Google__Protobuf__EnumDescriptorProto__EnumReservedRange Google__Protobuf__EnumDescriptorProto__EnumReservedRange;
typedef struct Google__Protobuf__EnumValueDescriptorProto Google__Protobuf__EnumValueDescriptorProto;
typedef struct Google__Protobuf__ServiceDescriptorProto Google__Protobuf__ServiceDescriptorProto;
typedef struct Google__Protobuf__MethodDescriptorProto Google__Protobuf__MethodDescriptorProto;
typedef struct Google__Protobuf__FileOptions Google__Protobuf__FileOptions;
typedef struct Google__Protobuf__MessageOptions Google__Protobuf__MessageOptions;
typedef struct Google__Protobuf__FieldOptions Google__Protobuf__FieldOptions;
typedef struct Google__Protobuf__OneofOptions Google__Protobuf__OneofOptions;
typedef struct Google__Protobuf__EnumOptions Google__Protobuf__EnumOptions;
typedef struct Google__Protobuf__EnumValueOptions Google__Protobuf__EnumValueOptions;
typedef struct Google__Protobuf__ServiceOptions Google__Protobuf__ServiceOptions;
typedef struct Google__Protobuf__MethodOptions Google__Protobuf__MethodOptions;
typedef struct Google__Protobuf__UninterpretedOption Google__Protobuf__UninterpretedOption;
typedef struct Google__Protobuf__UninterpretedOption__NamePart Google__Protobuf__UninterpretedOption__NamePart;
typedef struct Google__Protobuf__SourceCodeInfo Google__Protobuf__SourceCodeInfo;
typedef struct Google__Protobuf__SourceCodeInfo__Location Google__Protobuf__SourceCodeInfo__Location;
typedef struct Google__Protobuf__GeneratedCodeInfo Google__Protobuf__GeneratedCodeInfo;
typedef struct Google__Protobuf__GeneratedCodeInfo__Annotation Google__Protobuf__GeneratedCodeInfo__Annotation;


/* --- enums --- */

typedef enum _Google__Protobuf__FieldDescriptorProto__Type {
  /*
   * 0 is reserved for errors.
   * Order is weird for historical reasons.
   */
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_DOUBLE = 1,
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_FLOAT = 2,
  /*
   * Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
   * negative values are likely.
   */
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_INT64 = 3,
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_UINT64 = 4,
  /*
   * Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
   * negative values are likely.
   */
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_INT32 = 5,
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_FIXED64 = 6,
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_FIXED32 = 7,
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_BOOL = 8,
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_STRING = 9,
  /*
   * Tag-delimited aggregate.
   * Group type is deprecated and not supported in proto3. However, Proto3
   * implementations should still be able to parse the group wire format and
   * treat group fields as unknown fields.
   */
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_GROUP = 10,
  /*
   * Length-delimited aggregate.
   */
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_MESSAGE = 11,
  /*
   * New in version 2.
   */
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_BYTES = 12,
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_UINT32 = 13,
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_ENUM = 14,
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_SFIXED32 = 15,
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_SFIXED64 = 16,
  /*
   * Uses ZigZag encoding.
   */
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_SINT32 = 17,
  /*
   * Uses ZigZag encoding.
   */
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_SINT64 = 18
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE)
} Google__Protobuf__FieldDescriptorProto__Type;
typedef enum _Google__Protobuf__FieldDescriptorProto__Label {
  /*
   * 0 is reserved for errors
   */
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__LABEL__LABEL_OPTIONAL = 1,
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__LABEL__LABEL_REQUIRED = 2,
  GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__LABEL__LABEL_REPEATED = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__LABEL)
} Google__Protobuf__FieldDescriptorProto__Label;
/*
 * Generated classes can be optimized for speed or code size.
 */
typedef enum _Google__Protobuf__FileOptions__OptimizeMode {
  /*
   * Generate complete code for parsing, serialization,
   */
  GOOGLE__PROTOBUF__FILE_OPTIONS__OPTIMIZE_MODE__SPEED = 1,
  /*
   * etc.
   */
  /*
   * Use ReflectionOps to implement these methods.
   */
  GOOGLE__PROTOBUF__FILE_OPTIONS__OPTIMIZE_MODE__CODE_SIZE = 2,
  /*
   * Generate code using MessageLite and the lite runtime.
   */
  GOOGLE__PROTOBUF__FILE_OPTIONS__OPTIMIZE_MODE__LITE_RUNTIME = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(GOOGLE__PROTOBUF__FILE_OPTIONS__OPTIMIZE_MODE)
} Google__Protobuf__FileOptions__OptimizeMode;
typedef enum _Google__Protobuf__FieldOptions__CType {
  /*
   * Default mode.
   */
  GOOGLE__PROTOBUF__FIELD_OPTIONS__CTYPE__STRING = 0,
  GOOGLE__PROTOBUF__FIELD_OPTIONS__CTYPE__CORD = 1,
  GOOGLE__PROTOBUF__FIELD_OPTIONS__CTYPE__STRING_PIECE = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(GOOGLE__PROTOBUF__FIELD_OPTIONS__CTYPE)
} Google__Protobuf__FieldOptions__CType;
typedef enum _Google__Protobuf__FieldOptions__JSType {
  /*
   * Use the default type.
   */
  GOOGLE__PROTOBUF__FIELD_OPTIONS__JSTYPE__JS_NORMAL = 0,
  /*
   * Use JavaScript strings.
   */
  GOOGLE__PROTOBUF__FIELD_OPTIONS__JSTYPE__JS_STRING = 1,
  /*
   * Use JavaScript numbers.
   */
  GOOGLE__PROTOBUF__FIELD_OPTIONS__JSTYPE__JS_NUMBER = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(GOOGLE__PROTOBUF__FIELD_OPTIONS__JSTYPE)
} Google__Protobuf__FieldOptions__JSType;
/*
 * Is this method side-effect-free (or safe in HTTP parlance), or idempotent,
 * or neither? HTTP based RPC implementation may choose GET verb for safe
 * methods, and PUT verb for idempotent methods instead of the default POST.
 */
typedef enum _Google__Protobuf__MethodOptions__IdempotencyLevel {
  GOOGLE__PROTOBUF__METHOD_OPTIONS__IDEMPOTENCY_LEVEL__IDEMPOTENCY_UNKNOWN = 0,
  /*
   * implies idempotent
   */
  GOOGLE__PROTOBUF__METHOD_OPTIONS__IDEMPOTENCY_LEVEL__NO_SIDE_EFFECTS = 1,
  /*
   * idempotent, but may have side effects
   */
  GOOGLE__PROTOBUF__METHOD_OPTIONS__IDEMPOTENCY_LEVEL__IDEMPOTENT = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(GOOGLE__PROTOBUF__METHOD_OPTIONS__IDEMPOTENCY_LEVEL)
} Google__Protobuf__MethodOptions__IdempotencyLevel;

/* --- messages --- */

/*
 * The protocol compiler can output a FileDescriptorSet containing the .proto
 * files it parses.
 */
struct  Google__Protobuf__FileDescriptorSet
{
  ProtobufCMessage base;
  size_t n_file;
  Google__Protobuf__FileDescriptorProto **file;
};
#define GOOGLE__PROTOBUF__FILE_DESCRIPTOR_SET__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__file_descriptor_set__descriptor) \
    , 0,NULL }


/*
 * Describes a complete .proto file.
 */
struct  Google__Protobuf__FileDescriptorProto
{
  ProtobufCMessage base;
  /*
   * file name, relative to root of source tree
   */
  char *name;
  /*
   * e.g. "foo", "foo.bar", etc.
   */
  char *package;
  /*
   * Names of files imported by this file.
   */
  size_t n_dependency;
  char **dependency;
  /*
   * Indexes of the public imported files in the dependency list above.
   */
  size_t n_public_dependency;
  int32_t *public_dependency;
  /*
   * Indexes of the weak imported files in the dependency list.
   * For Google-internal migration only. Do not use.
   */
  size_t n_weak_dependency;
  int32_t *weak_dependency;
  /*
   * All top-level definitions in this file.
   */
  size_t n_message_type;
  Google__Protobuf__DescriptorProto **message_type;
  size_t n_enum_type;
  Google__Protobuf__EnumDescriptorProto **enum_type;
  size_t n_service;
  Google__Protobuf__ServiceDescriptorProto **service;
  size_t n_extension;
  Google__Protobuf__FieldDescriptorProto **extension;
  Google__Protobuf__FileOptions *options;
  /*
   * This field contains optional information about the original source code.
   * You may safely remove this entire field without harming runtime
   * functionality of the descriptors -- the information is needed only by
   * development tools.
   */
  Google__Protobuf__SourceCodeInfo *source_code_info;
  /*
   * The syntax of the proto file.
   * The supported values are "proto2" and "proto3".
   */
  char *syntax;
};
#define GOOGLE__PROTOBUF__FILE_DESCRIPTOR_PROTO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__file_descriptor_proto__descriptor) \
    , NULL, NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, NULL, NULL, NULL }


struct  Google__Protobuf__DescriptorProto__ExtensionRange
{
  ProtobufCMessage base;
  /*
   * Inclusive.
   */
  protobuf_c_boolean has_start;
  int32_t start;
  /*
   * Exclusive.
   */
  protobuf_c_boolean has_end;
  int32_t end;
  Google__Protobuf__ExtensionRangeOptions *options;
};
#define GOOGLE__PROTOBUF__DESCRIPTOR_PROTO__EXTENSION_RANGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__descriptor_proto__extension_range__descriptor) \
    , 0, 0, 0, 0, NULL }


/*
 * Range of reserved tag numbers. Reserved tag numbers may not be used by
 * fields or extension ranges in the same message. Reserved ranges may
 * not overlap.
 */
struct  Google__Protobuf__DescriptorProto__ReservedRange
{
  ProtobufCMessage base;
  /*
   * Inclusive.
   */
  protobuf_c_boolean has_start;
  int32_t start;
  /*
   * Exclusive.
   */
  protobuf_c_boolean has_end;
  int32_t end;
};
#define GOOGLE__PROTOBUF__DESCRIPTOR_PROTO__RESERVED_RANGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__descriptor_proto__reserved_range__descriptor) \
    , 0, 0, 0, 0 }


/*
 * Describes a message type.
 */
struct  Google__Protobuf__DescriptorProto
{
  ProtobufCMessage base;
  char *name;
  size_t n_field;
  Google__Protobuf__FieldDescriptorProto **field;
  size_t n_extension;
  Google__Protobuf__FieldDescriptorProto **extension;
  size_t n_nested_type;
  Google__Protobuf__DescriptorProto **nested_type;
  size_t n_enum_type;
  Google__Protobuf__EnumDescriptorProto **enum_type;
  size_t n_extension_range;
  Google__Protobuf__DescriptorProto__ExtensionRange **extension_range;
  size_t n_oneof_decl;
  Google__Protobuf__OneofDescriptorProto **oneof_decl;
  Google__Protobuf__MessageOptions *options;
  size_t n_reserved_range;
  Google__Protobuf__DescriptorProto__ReservedRange **reserved_range;
  /*
   * Reserved field names, which may not be used by fields in the same message.
   * A given name may only be reserved once.
   */
  size_t n_reserved_name;
  char **reserved_name;
};
#define GOOGLE__PROTOBUF__DESCRIPTOR_PROTO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__descriptor_proto__descriptor) \
    , NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, NULL, 0,NULL, 0,NULL }


struct  Google__Protobuf__ExtensionRangeOptions
{
  ProtobufCMessage base;
  /*
   * The parser stores options it doesn't recognize here. See above.
   */
  size_t n_uninterpreted_option;
  Google__Protobuf__UninterpretedOption **uninterpreted_option;
};
#define GOOGLE__PROTOBUF__EXTENSION_RANGE_OPTIONS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__extension_range_options__descriptor) \
    , 0,NULL }


/*
 * Describes a field within a message.
 */
struct  Google__Protobuf__FieldDescriptorProto
{
  ProtobufCMessage base;
  char *name;
  protobuf_c_boolean has_number;
  int32_t number;
  protobuf_c_boolean has_label;
  Google__Protobuf__FieldDescriptorProto__Label label;
  /*
   * If type_name is set, this need not be set.  If both this and type_name
   * are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
   */
  protobuf_c_boolean has_type;
  Google__Protobuf__FieldDescriptorProto__Type type;
  /*
   * For message and enum types, this is the name of the type.  If the name
   * starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
   * rules are used to find the type (i.e. first the nested types within this
   * message are searched, then within the parent, on up to the root
   * namespace).
   */
  char *type_name;
  /*
   * For extensions, this is the name of the type being extended.  It is
   * resolved in the same manner as type_name.
   */
  char *extendee;
  /*
   * For numeric types, contains the original text representation of the value.
   * For booleans, "true" or "false".
   * For strings, contains the default text contents (not escaped in any way).
   * For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
   */
  char *default_value;
  /*
   * If set, gives the index of a oneof in the containing type's oneof_decl
   * list.  This field is a member of that oneof.
   */
  protobuf_c_boolean has_oneof_index;
  int32_t oneof_index;
  /*
   * JSON name of this field. The value is set by protocol compiler. If the
   * user has set a "json_name" option on this field, that option's value
   * will be used. Otherwise, it's deduced from the field's name by converting
   * it to camelCase.
   */
  char *json_name;
  Google__Protobuf__FieldOptions *options;
  /*
   * If true, this is a proto3 "optional". When a proto3 field is optional, it
   * tracks presence regardless of field type.
   * When proto3_optional is true, this field must be belong to a oneof to
   * signal to old proto3 clients that presence is tracked for this field. This
   * oneof is known as a "synthetic" oneof, and this field must be its sole
   * member (each proto3 optional field gets its own synthetic oneof). Synthetic
   * oneofs exist in the descriptor only, and do not generate any API. Synthetic
   * oneofs must be ordered after all "real" oneofs.
   * For message fields, proto3_optional doesn't create any semantic change,
   * since non-repeated message fields always track presence. However it still
   * indicates the semantic detail of whether the user wrote "optional" or not.
   * This can be useful for round-tripping the .proto file. For consistency we
   * give message fields a synthetic oneof also, even though it is not required
   * to track presence. This is especially important because the parser can't
   * tell if a field is a message or an enum, so it must always create a
   * synthetic oneof.
   * Proto2 optional fields do not set this flag, because they already indicate
   * optional with `LABEL_OPTIONAL`.
   */
  protobuf_c_boolean has_proto3_optional;
  protobuf_c_boolean proto3_optional;
};
#define GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__field_descriptor_proto__descriptor) \
    , NULL, 0, 0, 0, GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__LABEL__LABEL_OPTIONAL, 0, GOOGLE__PROTOBUF__FIELD_DESCRIPTOR_PROTO__TYPE__TYPE_DOUBLE, NULL, NULL, NULL, 0, 0, NULL, NULL, 0, 0 }


/*
 * Describes a oneof.
 */
struct  Google__Protobuf__OneofDescriptorProto
{
  ProtobufCMessage base;
  char *name;
  Google__Protobuf__OneofOptions *options;
};
#define GOOGLE__PROTOBUF__ONEOF_DESCRIPTOR_PROTO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__oneof_descriptor_proto__descriptor) \
    , NULL, NULL }


/*
 * Range of reserved numeric values. Reserved values may not be used by
 * entries in the same enum. Reserved ranges may not overlap.
 * Note that this is distinct from DescriptorProto.ReservedRange in that it
 * is inclusive such that it can appropriately represent the entire int32
 * domain.
 */
struct  Google__Protobuf__EnumDescriptorProto__EnumReservedRange
{
  ProtobufCMessage base;
  /*
   * Inclusive.
   */
  protobuf_c_boolean has_start;
  int32_t start;
  /*
   * Inclusive.
   */
  protobuf_c_boolean has_end;
  int32_t end;
};
#define GOOGLE__PROTOBUF__ENUM_DESCRIPTOR_PROTO__ENUM_RESERVED_RANGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__enum_descriptor_proto__enum_reserved_range__descriptor) \
    , 0, 0, 0, 0 }


/*
 * Describes an enum type.
 */
struct  Google__Protobuf__EnumDescriptorProto
{
  ProtobufCMessage base;
  char *name;
  size_t n_value;
  Google__Protobuf__EnumValueDescriptorProto **value;
  Google__Protobuf__EnumOptions *options;
  /*
   * Range of reserved numeric values. Reserved numeric values may not be used
   * by enum values in the same enum declaration. Reserved ranges may not
   * overlap.
   */
  size_t n_reserved_range;
  Google__Protobuf__EnumDescriptorProto__EnumReservedRange **reserved_range;
  /*
   * Reserved enum value names, which may not be reused. A given name may only
   * be reserved once.
   */
  size_t n_reserved_name;
  char **reserved_name;
};
#define GOOGLE__PROTOBUF__ENUM_DESCRIPTOR_PROTO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__enum_descriptor_proto__descriptor) \
    , NULL, 0,NULL, NULL, 0,NULL, 0,NULL }


/*
 * Describes a value within an enum.
 */
struct  Google__Protobuf__EnumValueDescriptorProto
{
  ProtobufCMessage base;
  char *name;
  protobuf_c_boolean has_number;
  int32_t number;
  Google__Protobuf__EnumValueOptions *options;
};
#define GOOGLE__PROTOBUF__ENUM_VALUE_DESCRIPTOR_PROTO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__enum_value_descriptor_proto__descriptor) \
    , NULL, 0, 0, NULL }


/*
 * Describes a service.
 */
struct  Google__Protobuf__ServiceDescriptorProto
{
  ProtobufCMessage base;
  char *name;
  size_t n_method;
  Google__Protobuf__MethodDescriptorProto **method;
  Google__Protobuf__ServiceOptions *options;
};
#define GOOGLE__PROTOBUF__SERVICE_DESCRIPTOR_PROTO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__service_descriptor_proto__descriptor) \
    , NULL, 0,NULL, NULL }


/*
 * Describes a method of a service.
 */
struct  Google__Protobuf__MethodDescriptorProto
{
  ProtobufCMessage base;
  char *name;
  /*
   * Input and output type names.  These are resolved in the same way as
   * FieldDescriptorProto.type_name, but must refer to a message type.
   */
  char *input_type;
  char *output_type;
  Google__Protobuf__MethodOptions *options;
  /*
   * Identifies if client streams multiple client messages
   */
  protobuf_c_boolean has_client_streaming;
  protobuf_c_boolean client_streaming;
  /*
   * Identifies if server streams multiple server messages
   */
  protobuf_c_boolean has_server_streaming;
  protobuf_c_boolean server_streaming;
};
#define GOOGLE__PROTOBUF__METHOD_DESCRIPTOR_PROTO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__method_descriptor_proto__descriptor) \
    , NULL, NULL, NULL, NULL, 0, 0, 0, 0 }


struct  Google__Protobuf__FileOptions
{
  ProtobufCMessage base;
  /*
   * Sets the Java package where classes generated from this .proto will be
   * placed.  By default, the proto package is used, but this is often
   * inappropriate because proto packages do not normally start with backwards
   * domain names.
   */
  char *java_package;
  /*
   * Controls the name of the wrapper Java class generated for the .proto file.
   * That class will always contain the .proto file's getDescriptor() method as
   * well as any top-level extensions defined in the .proto file.
   * If java_multiple_files is disabled, then all the other classes from the
   * .proto file will be nested inside the single wrapper outer class.
   */
  char *java_outer_classname;
  /*
   * If enabled, then the Java code generator will generate a separate .java
   * file for each top-level message, enum, and service defined in the .proto
   * file.  Thus, these types will *not* be nested inside the wrapper class
   * named by java_outer_classname.  However, the wrapper class will still be
   * generated to contain the file's getDescriptor() method as well as any
   * top-level extensions defined in the file.
   */
  protobuf_c_boolean has_java_multiple_files;
  protobuf_c_boolean java_multiple_files;
  /*
   * This option does nothing.
   */
  protobuf_c_boolean has_java_generate_equals_and_hash PROTOBUF_C__DEPRECATED;
  protobuf_c_boolean java_generate_equals_and_hash PROTOBUF_C__DEPRECATED;
  /*
   * If set true, then the Java2 code generator will generate code that
   * throws an exception whenever an attempt is made to assign a non-UTF-8
   * byte sequence to a string field.
   * Message reflection will do the same.
   * However, an extension field still accepts non-UTF-8 byte sequences.
   * This option has no effect on when used with the lite runtime.
   */
  protobuf_c_boolean has_java_string_check_utf8;
  protobuf_c_boolean java_string_check_utf8;
  protobuf_c_boolean has_optimize_for;
  Google__Protobuf__FileOptions__OptimizeMode optimize_for;
  /*
   * Sets the Go package where structs generated from this .proto will be
   * placed. If omitted, the Go package will be derived from the following:
   *   - The basename of the package import path, if provided.
   *   - Otherwise, the package statement in the .proto file, if present.
   *   - Otherwise, the basename of the .proto file, without extension.
   */
  char *go_package;
  /*
   * Should generic services be generated in each language?  "Generic" services
   * are not specific to any particular RPC system.  They are generated by the
   * main code generators in each language (without additional plugins).
   * Generic services were the only kind of service generation supported by
   * early versions of google.protobuf.
   * Generic services are now considered deprecated in favor of using plugins
   * that generate code specific to your particular RPC system.  Therefore,
   * these default to false.  Old code which depends on generic services should
   * explicitly set them to true.
   */
  protobuf_c_boolean has_cc_generic_services;
  protobuf_c_boolean cc_generic_services;
  protobuf_c_boolean has_java_generic_services;
  protobuf_c_boolean java_generic_services;
  protobuf_c_boolean has_py_generic_services;
  protobuf_c_boolean py_generic_services;
  protobuf_c_boolean has_php_generic_services;
  protobuf_c_boolean php_generic_services;
  /*
   * Is this file deprecated?
   * Depending on the target platform, this can emit Deprecated annotations
   * for everything in the file, or it will be completely ignored; in the very
   * least, this is a formalization for deprecating files.
   */
  protobuf_c_boolean has_deprecated;
  protobuf_c_boolean deprecated;
  /*
   * Enables the use of arenas for the proto messages in this file. This applies
   * only to generated classes for C++.
   */
  protobuf_c_boolean has_cc_enable_arenas;
  protobuf_c_boolean cc_enable_arenas;
  /*
   * Sets the objective c class prefix which is prepended to all objective c
   * generated classes from this .proto. There is no default.
   */
  char *objc_class_prefix;
  /*
   * Namespace for generated classes; defaults to the package.
   */
  char *csharp_namespace;
  /*
   * By default Swift generators will take the proto package and CamelCase it
   * replacing '.' with underscore and use that to prefix the types/symbols
   * defined. When this options is provided, they will use this value instead
   * to prefix the types/symbols defined.
   */
  char *swift_prefix;
  /*
   * Sets the php class prefix which is prepended to all php generated classes
   * from this .proto. Default is empty.
   */
  char *php_class_prefix;
  /*
   * Use this option to change the namespace of php generated classes. Default
   * is empty. When this option is empty, the package name will be used for
   * determining the namespace.
   */
  char *php_namespace;
  /*
   * Use this option to change the namespace of php generated metadata classes.
   * Default is empty. When this option is empty, the proto file name will be
   * used for determining the namespace.
   */
  char *php_metadata_namespace;
  /*
   * Use this option to change the package of ruby generated classes. Default
   * is empty. When this option is not set, the package name will be used for
   * determining the ruby package.
   */
  char *ruby_package;
  /*
   * The parser stores options it doesn't recognize here.
   * See the documentation for the "Options" section above.
   */
  size_t n_uninterpreted_option;
  Google__Protobuf__UninterpretedOption **uninterpreted_option;
};
#define GOOGLE__PROTOBUF__FILE_OPTIONS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__file_options__descriptor) \
    , NULL, NULL, 0, 0, 0, 0, 0, 0, 0, GOOGLE__PROTOBUF__FILE_OPTIONS__OPTIMIZE_MODE__SPEED, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0,NULL }


struct  Google__Protobuf__MessageOptions
{
  ProtobufCMessage base;
  /*
   * Set true to use the old proto1 MessageSet wire format for extensions.
   * This is provided for backwards-compatibility with the MessageSet wire
   * format.  You should not use this for any other reason:  It's less
   * efficient, has fewer features, and is more complicated.
   * The message must be defined exactly as follows:
   *   message Foo {
   *     option message_set_wire_format = true;
   *     extensions 4 to max;
   *   }
   * Note that the message cannot have any defined fields; MessageSets only
   * have extensions.
   * All extensions of your type must be singular messages; e.g. they cannot
   * be int32s, enums, or repeated messages.
   * Because this is an option, the above two restrictions are not enforced by
   * the protocol compiler.
   */
  protobuf_c_boolean has_message_set_wire_format;
  protobuf_c_boolean message_set_wire_format;
  /*
   * Disables the generation of the standard "descriptor()" accessor, which can
   * conflict with a field of the same name.  This is meant to make migration
   * from proto1 easier; new code should avoid fields named "descriptor".
   */
  protobuf_c_boolean has_no_standard_descriptor_accessor;
  protobuf_c_boolean no_standard_descriptor_accessor;
  /*
   * Is this message deprecated?
   * Depending on the target platform, this can emit Deprecated annotations
   * for the message, or it will be completely ignored; in the very least,
   * this is a formalization for deprecating messages.
   */
  protobuf_c_boolean has_deprecated;
  protobuf_c_boolean deprecated;
  /*
   * Whether the message is an automatically generated map entry type for the
   * maps field.
   * For maps fields:
   *     map<KeyType, ValueType> map_field = 1;
   * The parsed descriptor looks like:
   *     message MapFieldEntry {
   *         option map_entry = true;
   *         optional KeyType key = 1;
   *         optional ValueType value = 2;
   *     }
   *     repeated MapFieldEntry map_field = 1;
   * Implementations may choose not to generate the map_entry=true message, but
   * use a native map in the target language to hold the keys and values.
   * The reflection APIs in such implementations still need to work as
   * if the field is a repeated message field.
   * NOTE: Do not set the option in .proto files. Always use the maps syntax
   * instead. The option should only be implicitly set by the proto compiler
   * parser.
   */
  protobuf_c_boolean has_map_entry;
  protobuf_c_boolean map_entry;
  /*
   * The parser stores options it doesn't recognize here. See above.
   */
  size_t n_uninterpreted_option;
  Google__Protobuf__UninterpretedOption **uninterpreted_option;
};
#define GOOGLE__PROTOBUF__MESSAGE_OPTIONS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__message_options__descriptor) \
    , 0, 0, 0, 0, 0, 0, 0, 0, 0,NULL }


struct  Google__Protobuf__FieldOptions
{
  ProtobufCMessage base;
  /*
   * The ctype option instructs the C++ code generator to use a different
   * representation of the field than it normally would.  See the specific
   * options below.  This option is not yet implemented in the open source
   * release -- sorry, we'll try to include it in a future version!
   */
  protobuf_c_boolean has_ctype;
  Google__Protobuf__FieldOptions__CType ctype;
  /*
   * The packed option can be enabled for repeated primitive fields to enable
   * a more efficient representation on the wire. Rather than repeatedly
   * writing the tag and type for each element, the entire array is encoded as
   * a single length-delimited blob. In proto3, only explicit setting it to
   * false will avoid using packed encoding.
   */
  protobuf_c_boolean has_packed;
  protobuf_c_boolean packed;
  /*
   * The jstype option determines the JavaScript type used for values of the
   * field.  The option is permitted only for 64 bit integral and fixed types
   * (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
   * is represented as JavaScript string, which avoids loss of precision that
   * can happen when a large value is converted to a floating point JavaScript.
   * Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
   * use the JavaScript "number" type.  The behavior of the default option
   * JS_NORMAL is implementation dependent.
   * This option is an enum to permit additional types to be added, e.g.
   * goog.math.Integer.
   */
  protobuf_c_boolean has_jstype;
  Google__Protobuf__FieldOptions__JSType jstype;
  /*
   * Should this field be parsed lazily?  Lazy applies only to message-type
   * fields.  It means that when the outer message is initially parsed, the
   * inner message's contents will not be parsed but instead stored in encoded
   * form.  The inner message will actually be parsed when it is first accessed.
   * This is only a hint.  Implementations are free to choose whether to use
   * eager or lazy parsing regardless of the value of this option.  However,
   * setting this option true suggests that the protocol author believes that
   * using lazy parsing on this field is worth the additional bookkeeping
   * overhead typically needed to implement it.
   * This option does not affect the public interface of any generated code;
   * all method signatures remain the same.  Furthermore, thread-safety of the
   * interface is not affected by this option; const methods remain safe to
   * call from multiple threads concurrently, while non-const methods continue
   * to require exclusive access.
   * Note that implementations may choose not to check required fields within
   * a lazy sub-message.  That is, calling IsInitialized() on the outer message
   * may return true even if the inner message has missing required fields.
   * This is necessary because otherwise the inner message would have to be
   * parsed in order to perform the check, defeating the purpose of lazy
   * parsing.  An implementation which chooses not to check required fields
   * must be consistent about it.  That is, for any particular sub-message, the
   * implementation must either *always* check its required fields, or *never*
   * check its required fields, regardless of whether or not the message has
   * been parsed.
   * As of 2021, lazy does no correctness checks on the byte stream during
   * parsing.  This may lead to crashes if and when an invalid byte stream is
   * finally parsed upon access.
   * TODO(b/211906113):  Enable validation on lazy fields.
   */
  protobuf_c_boolean has_lazy;
  protobuf_c_boolean lazy;
  /*
   * unverified_lazy does no correctness checks on the byte stream. This should
   * only be used where lazy with verification is prohibitive for performance
   * reasons.
   */
  protobuf_c_boolean has_unverified_lazy;
  protobuf_c_boolean unverified_lazy;
  /*
   * Is this field deprecated?
   * Depending on the target platform, this can emit Deprecated annotations
   * for accessors, or it will be completely ignored; in the very least, this
   * is a formalization for deprecating fields.
   */
  protobuf_c_boolean has_deprecated;
  protobuf_c_boolean deprecated;
  /*
   * For Google-internal migration only. Do not use.
   */
  protobuf_c_boolean has_weak;
  protobuf_c_boolean weak;
  /*
   * The parser stores options it doesn't recognize here. See above.
   */
  size_t n_uninterpreted_option;
  Google__Protobuf__UninterpretedOption **uninterpreted_option;
};
#define GOOGLE__PROTOBUF__FIELD_OPTIONS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__field_options__descriptor) \
    , 0, GOOGLE__PROTOBUF__FIELD_OPTIONS__CTYPE__STRING, 0, 0, 0, GOOGLE__PROTOBUF__FIELD_OPTIONS__JSTYPE__JS_NORMAL, 0, 0, 0, 0, 0, 0, 0, 0, 0,NULL }


struct  Google__Protobuf__OneofOptions
{
  ProtobufCMessage base;
  /*
   * The parser stores options it doesn't recognize here. See above.
   */
  size_t n_uninterpreted_option;
  Google__Protobuf__UninterpretedOption **uninterpreted_option;
};
#define GOOGLE__PROTOBUF__ONEOF_OPTIONS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__oneof_options__descriptor) \
    , 0,NULL }


struct  Google__Protobuf__EnumOptions
{
  ProtobufCMessage base;
  /*
   * Set this option to true to allow mapping different tag names to the same
   * value.
   */
  protobuf_c_boolean has_allow_alias;
  protobuf_c_boolean allow_alias;
  /*
   * Is this enum deprecated?
   * Depending on the target platform, this can emit Deprecated annotations
   * for the enum, or it will be completely ignored; in the very least, this
   * is a formalization for deprecating enums.
   */
  protobuf_c_boolean has_deprecated;
  protobuf_c_boolean deprecated;
  /*
   * The parser stores options it doesn't recognize here. See above.
   */
  size_t n_uninterpreted_option;
  Google__Protobuf__UninterpretedOption **uninterpreted_option;
};
#define GOOGLE__PROTOBUF__ENUM_OPTIONS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__enum_options__descriptor) \
    , 0, 0, 0, 0, 0,NULL }


struct  Google__Protobuf__EnumValueOptions
{
  ProtobufCMessage base;
  /*
   * Is this enum value deprecated?
   * Depending on the target platform, this can emit Deprecated annotations
   * for the enum value, or it will be completely ignored; in the very least,
   * this is a formalization for deprecating enum values.
   */
  protobuf_c_boolean has_deprecated;
  protobuf_c_boolean deprecated;
  /*
   * The parser stores options it doesn't recognize here. See above.
   */
  size_t n_uninterpreted_option;
  Google__Protobuf__UninterpretedOption **uninterpreted_option;
};
#define GOOGLE__PROTOBUF__ENUM_VALUE_OPTIONS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__enum_value_options__descriptor) \
    , 0, 0, 0,NULL }


struct  Google__Protobuf__ServiceOptions
{
  ProtobufCMessage base;
  /*
   * Is this service deprecated?
   * Depending on the target platform, this can emit Deprecated annotations
   * for the service, or it will be completely ignored; in the very least,
   * this is a formalization for deprecating services.
   */
  protobuf_c_boolean has_deprecated;
  protobuf_c_boolean deprecated;
  /*
   * The parser stores options it doesn't recognize here. See above.
   */
  size_t n_uninterpreted_option;
  Google__Protobuf__UninterpretedOption **uninterpreted_option;
};
#define GOOGLE__PROTOBUF__SERVICE_OPTIONS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__service_options__descriptor) \
    , 0, 0, 0,NULL }


struct  Google__Protobuf__MethodOptions
{
  ProtobufCMessage base;
  /*
   * Is this method deprecated?
   * Depending on the target platform, this can emit Deprecated annotations
   * for the method, or it will be completely ignored; in the very least,
   * this is a formalization for deprecating methods.
   */
  protobuf_c_boolean has_deprecated;
  protobuf_c_boolean deprecated;
  protobuf_c_boolean has_idempotency_level;
  Google__Protobuf__MethodOptions__IdempotencyLevel idempotency_level;
  /*
   * The parser stores options it doesn't recognize here. See above.
   */
  size_t n_uninterpreted_option;
  Google__Protobuf__UninterpretedOption **uninterpreted_option;
};
#define GOOGLE__PROTOBUF__METHOD_OPTIONS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__method_options__descriptor) \
    , 0, 0, 0, GOOGLE__PROTOBUF__METHOD_OPTIONS__IDEMPOTENCY_LEVEL__IDEMPOTENCY_UNKNOWN, 0,NULL }


/*
 * The name of the uninterpreted option.  Each string represents a segment in
 * a dot-separated name.  is_extension is true iff a segment represents an
 * extension (denoted with parentheses in options specs in .proto files).
 * E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
 * "foo.(bar.baz).qux".
 */
struct  Google__Protobuf__UninterpretedOption__NamePart
{
  ProtobufCMessage base;
  char *name_part;
  protobuf_c_boolean is_extension;
};
#define GOOGLE__PROTOBUF__UNINTERPRETED_OPTION__NAME_PART__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__uninterpreted_option__name_part__descriptor) \
    , NULL, 0 }


/*
 * A message representing a option the parser does not recognize. This only
 * appears in options protos created by the compiler::Parser class.
 * DescriptorPool resolves these when building Descriptor objects. Therefore,
 * options protos in descriptor objects (e.g. returned by Descriptor::options(),
 * or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
 * in them.
 */
struct  Google__Protobuf__UninterpretedOption
{
  ProtobufCMessage base;
  size_t n_name;
  Google__Protobuf__UninterpretedOption__NamePart **name;
  /*
   * The value of the uninterpreted option, in whatever type the tokenizer
   * identified it as during parsing. Exactly one of these should be set.
   */
  char *identifier_value;
  protobuf_c_boolean has_positive_int_value;
  uint64_t positive_int_value;
  protobuf_c_boolean has_negative_int_value;
  int64_t negative_int_value;
  protobuf_c_boolean has_double_value;
  double double_value;
  protobuf_c_boolean has_string_value;
  ProtobufCBinaryData string_value;
  char *aggregate_value;
};
#define GOOGLE__PROTOBUF__UNINTERPRETED_OPTION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__uninterpreted_option__descriptor) \
    , 0,NULL, NULL, 0, 0, 0, 0, 0, 0, 0, {0,NULL}, NULL }


struct  Google__Protobuf__SourceCodeInfo__Location
{
  ProtobufCMessage base;
  /*
   * Identifies which part of the FileDescriptorProto was defined at this
   * location.
   * Each element is a field number or an index.  They form a path from
   * the root FileDescriptorProto to the place where the definition occurs.
   * For example, this path:
   *   [ 4, 3, 2, 7, 1 ]
   * refers to:
   *   file.message_type(3)  // 4, 3
   *       .field(7)         // 2, 7
   *       .name()           // 1
   * This is because FileDescriptorProto.message_type has field number 4:
   *   repeated DescriptorProto message_type = 4;
   * and DescriptorProto.field has field number 2:
   *   repeated FieldDescriptorProto field = 2;
   * and FieldDescriptorProto.name has field number 1:
   *   optional string name = 1;
   * Thus, the above path gives the location of a field name.  If we removed
   * the last element:
   *   [ 4, 3, 2, 7 ]
   * this path refers to the whole field declaration (from the beginning
   * of the label to the terminating semicolon).
   */
  size_t n_path;
  int32_t *path;
  /*
   * Always has exactly three or four elements: start line, start column,
   * end line (optional, otherwise assumed same as start line), end column.
   * These are packed into a single field for efficiency.  Note that line
   * and column numbers are zero-based -- typically you will want to add
   * 1 to each before displaying to a user.
   */
  size_t n_span;
  int32_t *span;
  /*
   * If this SourceCodeInfo represents a complete declaration, these are any
   * comments appearing before and after the declaration which appear to be
   * attached to the declaration.
   * A series of line comments appearing on consecutive lines, with no other
   * tokens appearing on those lines, will be treated as a single comment.
   * leading_detached_comments will keep paragraphs of comments that appear
   * before (but not connected to) the current element. Each paragraph,
   * separated by empty lines, will be one comment element in the repeated
   * field.
   * Only the comment content is provided; comment markers (e.g. //) are
   * stripped out.  For block comments, leading whitespace and an asterisk
   * will be stripped from the beginning of each line other than the first.
   * Newlines are included in the output.
   * Examples:
   *   optional int32 foo = 1;  // Comment attached to foo.
   *   // Comment attached to bar.
   *   optional int32 bar = 2;
   *   optional string baz = 3;
   *   // Comment attached to baz.
   *   // Another line attached to baz.
   *   // Comment attached to qux.
   *   //
   *   // Another line attached to qux.
   *   optional double qux = 4;
   *   // Detached comment for corge. This is not leading or trailing comments
   *   // to qux or corge because there are blank lines separating it from
   *   // both.
   *   // Detached comment for corge paragraph 2.
   *   optional string corge = 5;
   *    * Block comment attached
   *    * to corge.  Leading asterisks
   *    * will be removed. * 
   *    * Block comment attached to
   *    * grault. * 
   *   optional int32 grault = 6;
   *   // ignored detached comments.
   */
  char *leading_comments;
  char *trailing_comments;
  size_t n_leading_detached_comments;
  char **leading_detached_comments;
};
#define GOOGLE__PROTOBUF__SOURCE_CODE_INFO__LOCATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__source_code_info__location__descriptor) \
    , 0,NULL, 0,NULL, NULL, NULL, 0,NULL }


/*
 * Encapsulates information about the original source file from which a
 * FileDescriptorProto was generated.
 */
struct  Google__Protobuf__SourceCodeInfo
{
  ProtobufCMessage base;
  /*
   * A Location identifies a piece of source code in a .proto file which
   * corresponds to a particular definition.  This information is intended
   * to be useful to IDEs, code indexers, documentation generators, and similar
   * tools.
   * For example, say we have a file like:
   *   message Foo {
   *     optional string foo = 1;
   *   }
   * Let's look at just the field definition:
   *   optional string foo = 1;
   *   ^       ^^     ^^  ^  ^^^
   *   a       bc     de  f  ghi
   * We have the following locations:
   *   span   path               represents
   *   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
   *   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
   *   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
   *   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
   *   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
   * Notes:
   * - A location may refer to a repeated field itself (i.e. not to any
   *   particular index within it).  This is used whenever a set of elements are
   *   logically enclosed in a single code segment.  For example, an entire
   *   extend block (possibly containing multiple extension definitions) will
   *   have an outer location whose path refers to the "extensions" repeated
   *   field without an index.
   * - Multiple locations may have the same path.  This happens when a single
   *   logical declaration is spread out across multiple places.  The most
   *   obvious example is the "extend" block again -- there may be multiple
   *   extend blocks in the same scope, each of which will have the same path.
   * - A location's span is not always a subset of its parent's span.  For
   *   example, the "extendee" of an extension declaration appears at the
   *   beginning of the "extend" block and is shared by all extensions within
   *   the block.
   * - Just because a location's span is a subset of some other location's span
   *   does not mean that it is a descendant.  For example, a "group" defines
   *   both a type and a field in a single declaration.  Thus, the locations
   *   corresponding to the type and field and their components will overlap.
   * - Code which tries to interpret locations should probably be designed to
   *   ignore those that it doesn't understand, as more types of locations could
   *   be recorded in the future.
   */
  size_t n_location;
  Google__Protobuf__SourceCodeInfo__Location **location;
};
#define GOOGLE__PROTOBUF__SOURCE_CODE_INFO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__source_code_info__descriptor) \
    , 0,NULL }


struct  Google__Protobuf__GeneratedCodeInfo__Annotation
{
  ProtobufCMessage base;
  /*
   * Identifies the element in the original source .proto file. This field
   * is formatted the same as SourceCodeInfo.Location.path.
   */
  size_t n_path;
  int32_t *path;
  /*
   * Identifies the filesystem path to the original source .proto.
   */
  char *source_file;
  /*
   * Identifies the starting offset in bytes in the generated code
   * that relates to the identified object.
   */
  protobuf_c_boolean has_begin;
  int32_t begin;
  /*
   * Identifies the ending offset in bytes in the generated code that
   * relates to the identified offset. The end offset should be one past
   * the last relevant byte (so the length of the text = end - begin).
   */
  protobuf_c_boolean has_end;
  int32_t end;
};
#define GOOGLE__PROTOBUF__GENERATED_CODE_INFO__ANNOTATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__generated_code_info__annotation__descriptor) \
    , 0,NULL, NULL, 0, 0, 0, 0 }


/*
 * Describes the relationship between generated code and its original source
 * file. A GeneratedCodeInfo message is associated with only one generated
 * source file, but may contain references to different source .proto files.
 */
struct  Google__Protobuf__GeneratedCodeInfo
{
  ProtobufCMessage base;
  /*
   * An Annotation connects some span of text in generated code to an element
   * of its generating .proto file.
   */
  size_t n_annotation;
  Google__Protobuf__GeneratedCodeInfo__Annotation **annotation;
};
#define GOOGLE__PROTOBUF__GENERATED_CODE_INFO__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&google__protobuf__generated_code_info__descriptor) \
    , 0,NULL }


/* Google__Protobuf__FileDescriptorSet methods */
void   google__protobuf__file_descriptor_set__init
                     (Google__Protobuf__FileDescriptorSet         *message);
size_t google__protobuf__file_descriptor_set__get_packed_size
                     (const Google__Protobuf__FileDescriptorSet   *message);
size_t google__protobuf__file_descriptor_set__pack
                     (const Google__Protobuf__FileDescriptorSet   *message,
                      uint8_t             *out);
size_t google__protobuf__file_descriptor_set__pack_to_buffer
                     (const Google__Protobuf__FileDescriptorSet   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__FileDescriptorSet *
       google__protobuf__file_descriptor_set__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__file_descriptor_set__free_unpacked
                     (Google__Protobuf__FileDescriptorSet *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__FileDescriptorProto methods */
void   google__protobuf__file_descriptor_proto__init
                     (Google__Protobuf__FileDescriptorProto         *message);
size_t google__protobuf__file_descriptor_proto__get_packed_size
                     (const Google__Protobuf__FileDescriptorProto   *message);
size_t google__protobuf__file_descriptor_proto__pack
                     (const Google__Protobuf__FileDescriptorProto   *message,
                      uint8_t             *out);
size_t google__protobuf__file_descriptor_proto__pack_to_buffer
                     (const Google__Protobuf__FileDescriptorProto   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__FileDescriptorProto *
       google__protobuf__file_descriptor_proto__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__file_descriptor_proto__free_unpacked
                     (Google__Protobuf__FileDescriptorProto *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__DescriptorProto__ExtensionRange methods */
void   google__protobuf__descriptor_proto__extension_range__init
                     (Google__Protobuf__DescriptorProto__ExtensionRange         *message);
/* Google__Protobuf__DescriptorProto__ReservedRange methods */
void   google__protobuf__descriptor_proto__reserved_range__init
                     (Google__Protobuf__DescriptorProto__ReservedRange         *message);
/* Google__Protobuf__DescriptorProto methods */
void   google__protobuf__descriptor_proto__init
                     (Google__Protobuf__DescriptorProto         *message);
size_t google__protobuf__descriptor_proto__get_packed_size
                     (const Google__Protobuf__DescriptorProto   *message);
size_t google__protobuf__descriptor_proto__pack
                     (const Google__Protobuf__DescriptorProto   *message,
                      uint8_t             *out);
size_t google__protobuf__descriptor_proto__pack_to_buffer
                     (const Google__Protobuf__DescriptorProto   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__DescriptorProto *
       google__protobuf__descriptor_proto__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__descriptor_proto__free_unpacked
                     (Google__Protobuf__DescriptorProto *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__ExtensionRangeOptions methods */
void   google__protobuf__extension_range_options__init
                     (Google__Protobuf__ExtensionRangeOptions         *message);
size_t google__protobuf__extension_range_options__get_packed_size
                     (const Google__Protobuf__ExtensionRangeOptions   *message);
size_t google__protobuf__extension_range_options__pack
                     (const Google__Protobuf__ExtensionRangeOptions   *message,
                      uint8_t             *out);
size_t google__protobuf__extension_range_options__pack_to_buffer
                     (const Google__Protobuf__ExtensionRangeOptions   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__ExtensionRangeOptions *
       google__protobuf__extension_range_options__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__extension_range_options__free_unpacked
                     (Google__Protobuf__ExtensionRangeOptions *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__FieldDescriptorProto methods */
void   google__protobuf__field_descriptor_proto__init
                     (Google__Protobuf__FieldDescriptorProto         *message);
size_t google__protobuf__field_descriptor_proto__get_packed_size
                     (const Google__Protobuf__FieldDescriptorProto   *message);
size_t google__protobuf__field_descriptor_proto__pack
                     (const Google__Protobuf__FieldDescriptorProto   *message,
                      uint8_t             *out);
size_t google__protobuf__field_descriptor_proto__pack_to_buffer
                     (const Google__Protobuf__FieldDescriptorProto   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__FieldDescriptorProto *
       google__protobuf__field_descriptor_proto__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__field_descriptor_proto__free_unpacked
                     (Google__Protobuf__FieldDescriptorProto *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__OneofDescriptorProto methods */
void   google__protobuf__oneof_descriptor_proto__init
                     (Google__Protobuf__OneofDescriptorProto         *message);
size_t google__protobuf__oneof_descriptor_proto__get_packed_size
                     (const Google__Protobuf__OneofDescriptorProto   *message);
size_t google__protobuf__oneof_descriptor_proto__pack
                     (const Google__Protobuf__OneofDescriptorProto   *message,
                      uint8_t             *out);
size_t google__protobuf__oneof_descriptor_proto__pack_to_buffer
                     (const Google__Protobuf__OneofDescriptorProto   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__OneofDescriptorProto *
       google__protobuf__oneof_descriptor_proto__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__oneof_descriptor_proto__free_unpacked
                     (Google__Protobuf__OneofDescriptorProto *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__EnumDescriptorProto__EnumReservedRange methods */
void   google__protobuf__enum_descriptor_proto__enum_reserved_range__init
                     (Google__Protobuf__EnumDescriptorProto__EnumReservedRange         *message);
/* Google__Protobuf__EnumDescriptorProto methods */
void   google__protobuf__enum_descriptor_proto__init
                     (Google__Protobuf__EnumDescriptorProto         *message);
size_t google__protobuf__enum_descriptor_proto__get_packed_size
                     (const Google__Protobuf__EnumDescriptorProto   *message);
size_t google__protobuf__enum_descriptor_proto__pack
                     (const Google__Protobuf__EnumDescriptorProto   *message,
                      uint8_t             *out);
size_t google__protobuf__enum_descriptor_proto__pack_to_buffer
                     (const Google__Protobuf__EnumDescriptorProto   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__EnumDescriptorProto *
       google__protobuf__enum_descriptor_proto__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__enum_descriptor_proto__free_unpacked
                     (Google__Protobuf__EnumDescriptorProto *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__EnumValueDescriptorProto methods */
void   google__protobuf__enum_value_descriptor_proto__init
                     (Google__Protobuf__EnumValueDescriptorProto         *message);
size_t google__protobuf__enum_value_descriptor_proto__get_packed_size
                     (const Google__Protobuf__EnumValueDescriptorProto   *message);
size_t google__protobuf__enum_value_descriptor_proto__pack
                     (const Google__Protobuf__EnumValueDescriptorProto   *message,
                      uint8_t             *out);
size_t google__protobuf__enum_value_descriptor_proto__pack_to_buffer
                     (const Google__Protobuf__EnumValueDescriptorProto   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__EnumValueDescriptorProto *
       google__protobuf__enum_value_descriptor_proto__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__enum_value_descriptor_proto__free_unpacked
                     (Google__Protobuf__EnumValueDescriptorProto *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__ServiceDescriptorProto methods */
void   google__protobuf__service_descriptor_proto__init
                     (Google__Protobuf__ServiceDescriptorProto         *message);
size_t google__protobuf__service_descriptor_proto__get_packed_size
                     (const Google__Protobuf__ServiceDescriptorProto   *message);
size_t google__protobuf__service_descriptor_proto__pack
                     (const Google__Protobuf__ServiceDescriptorProto   *message,
                      uint8_t             *out);
size_t google__protobuf__service_descriptor_proto__pack_to_buffer
                     (const Google__Protobuf__ServiceDescriptorProto   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__ServiceDescriptorProto *
       google__protobuf__service_descriptor_proto__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__service_descriptor_proto__free_unpacked
                     (Google__Protobuf__ServiceDescriptorProto *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__MethodDescriptorProto methods */
void   google__protobuf__method_descriptor_proto__init
                     (Google__Protobuf__MethodDescriptorProto         *message);
size_t google__protobuf__method_descriptor_proto__get_packed_size
                     (const Google__Protobuf__MethodDescriptorProto   *message);
size_t google__protobuf__method_descriptor_proto__pack
                     (const Google__Protobuf__MethodDescriptorProto   *message,
                      uint8_t             *out);
size_t google__protobuf__method_descriptor_proto__pack_to_buffer
                     (const Google__Protobuf__MethodDescriptorProto   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__MethodDescriptorProto *
       google__protobuf__method_descriptor_proto__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__method_descriptor_proto__free_unpacked
                     (Google__Protobuf__MethodDescriptorProto *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__FileOptions methods */
void   google__protobuf__file_options__init
                     (Google__Protobuf__FileOptions         *message);
size_t google__protobuf__file_options__get_packed_size
                     (const Google__Protobuf__FileOptions   *message);
size_t google__protobuf__file_options__pack
                     (const Google__Protobuf__FileOptions   *message,
                      uint8_t             *out);
size_t google__protobuf__file_options__pack_to_buffer
                     (const Google__Protobuf__FileOptions   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__FileOptions *
       google__protobuf__file_options__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__file_options__free_unpacked
                     (Google__Protobuf__FileOptions *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__MessageOptions methods */
void   google__protobuf__message_options__init
                     (Google__Protobuf__MessageOptions         *message);
size_t google__protobuf__message_options__get_packed_size
                     (const Google__Protobuf__MessageOptions   *message);
size_t google__protobuf__message_options__pack
                     (const Google__Protobuf__MessageOptions   *message,
                      uint8_t             *out);
size_t google__protobuf__message_options__pack_to_buffer
                     (const Google__Protobuf__MessageOptions   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__MessageOptions *
       google__protobuf__message_options__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__message_options__free_unpacked
                     (Google__Protobuf__MessageOptions *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__FieldOptions methods */
void   google__protobuf__field_options__init
                     (Google__Protobuf__FieldOptions         *message);
size_t google__protobuf__field_options__get_packed_size
                     (const Google__Protobuf__FieldOptions   *message);
size_t google__protobuf__field_options__pack
                     (const Google__Protobuf__FieldOptions   *message,
                      uint8_t             *out);
size_t google__protobuf__field_options__pack_to_buffer
                     (const Google__Protobuf__FieldOptions   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__FieldOptions *
       google__protobuf__field_options__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__field_options__free_unpacked
                     (Google__Protobuf__FieldOptions *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__OneofOptions methods */
void   google__protobuf__oneof_options__init
                     (Google__Protobuf__OneofOptions         *message);
size_t google__protobuf__oneof_options__get_packed_size
                     (const Google__Protobuf__OneofOptions   *message);
size_t google__protobuf__oneof_options__pack
                     (const Google__Protobuf__OneofOptions   *message,
                      uint8_t             *out);
size_t google__protobuf__oneof_options__pack_to_buffer
                     (const Google__Protobuf__OneofOptions   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__OneofOptions *
       google__protobuf__oneof_options__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__oneof_options__free_unpacked
                     (Google__Protobuf__OneofOptions *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__EnumOptions methods */
void   google__protobuf__enum_options__init
                     (Google__Protobuf__EnumOptions         *message);
size_t google__protobuf__enum_options__get_packed_size
                     (const Google__Protobuf__EnumOptions   *message);
size_t google__protobuf__enum_options__pack
                     (const Google__Protobuf__EnumOptions   *message,
                      uint8_t             *out);
size_t google__protobuf__enum_options__pack_to_buffer
                     (const Google__Protobuf__EnumOptions   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__EnumOptions *
       google__protobuf__enum_options__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__enum_options__free_unpacked
                     (Google__Protobuf__EnumOptions *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__EnumValueOptions methods */
void   google__protobuf__enum_value_options__init
                     (Google__Protobuf__EnumValueOptions         *message);
size_t google__protobuf__enum_value_options__get_packed_size
                     (const Google__Protobuf__EnumValueOptions   *message);
size_t google__protobuf__enum_value_options__pack
                     (const Google__Protobuf__EnumValueOptions   *message,
                      uint8_t             *out);
size_t google__protobuf__enum_value_options__pack_to_buffer
                     (const Google__Protobuf__EnumValueOptions   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__EnumValueOptions *
       google__protobuf__enum_value_options__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__enum_value_options__free_unpacked
                     (Google__Protobuf__EnumValueOptions *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__ServiceOptions methods */
void   google__protobuf__service_options__init
                     (Google__Protobuf__ServiceOptions         *message);
size_t google__protobuf__service_options__get_packed_size
                     (const Google__Protobuf__ServiceOptions   *message);
size_t google__protobuf__service_options__pack
                     (const Google__Protobuf__ServiceOptions   *message,
                      uint8_t             *out);
size_t google__protobuf__service_options__pack_to_buffer
                     (const Google__Protobuf__ServiceOptions   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__ServiceOptions *
       google__protobuf__service_options__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__service_options__free_unpacked
                     (Google__Protobuf__ServiceOptions *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__MethodOptions methods */
void   google__protobuf__method_options__init
                     (Google__Protobuf__MethodOptions         *message);
size_t google__protobuf__method_options__get_packed_size
                     (const Google__Protobuf__MethodOptions   *message);
size_t google__protobuf__method_options__pack
                     (const Google__Protobuf__MethodOptions   *message,
                      uint8_t             *out);
size_t google__protobuf__method_options__pack_to_buffer
                     (const Google__Protobuf__MethodOptions   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__MethodOptions *
       google__protobuf__method_options__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__method_options__free_unpacked
                     (Google__Protobuf__MethodOptions *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__UninterpretedOption__NamePart methods */
void   google__protobuf__uninterpreted_option__name_part__init
                     (Google__Protobuf__UninterpretedOption__NamePart         *message);
/* Google__Protobuf__UninterpretedOption methods */
void   google__protobuf__uninterpreted_option__init
                     (Google__Protobuf__UninterpretedOption         *message);
size_t google__protobuf__uninterpreted_option__get_packed_size
                     (const Google__Protobuf__UninterpretedOption   *message);
size_t google__protobuf__uninterpreted_option__pack
                     (const Google__Protobuf__UninterpretedOption   *message,
                      uint8_t             *out);
size_t google__protobuf__uninterpreted_option__pack_to_buffer
                     (const Google__Protobuf__UninterpretedOption   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__UninterpretedOption *
       google__protobuf__uninterpreted_option__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__uninterpreted_option__free_unpacked
                     (Google__Protobuf__UninterpretedOption *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__SourceCodeInfo__Location methods */
void   google__protobuf__source_code_info__location__init
                     (Google__Protobuf__SourceCodeInfo__Location         *message);
/* Google__Protobuf__SourceCodeInfo methods */
void   google__protobuf__source_code_info__init
                     (Google__Protobuf__SourceCodeInfo         *message);
size_t google__protobuf__source_code_info__get_packed_size
                     (const Google__Protobuf__SourceCodeInfo   *message);
size_t google__protobuf__source_code_info__pack
                     (const Google__Protobuf__SourceCodeInfo   *message,
                      uint8_t             *out);
size_t google__protobuf__source_code_info__pack_to_buffer
                     (const Google__Protobuf__SourceCodeInfo   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__SourceCodeInfo *
       google__protobuf__source_code_info__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__source_code_info__free_unpacked
                     (Google__Protobuf__SourceCodeInfo *message,
                      ProtobufCAllocator *allocator);
/* Google__Protobuf__GeneratedCodeInfo__Annotation methods */
void   google__protobuf__generated_code_info__annotation__init
                     (Google__Protobuf__GeneratedCodeInfo__Annotation         *message);
/* Google__Protobuf__GeneratedCodeInfo methods */
void   google__protobuf__generated_code_info__init
                     (Google__Protobuf__GeneratedCodeInfo         *message);
size_t google__protobuf__generated_code_info__get_packed_size
                     (const Google__Protobuf__GeneratedCodeInfo   *message);
size_t google__protobuf__generated_code_info__pack
                     (const Google__Protobuf__GeneratedCodeInfo   *message,
                      uint8_t             *out);
size_t google__protobuf__generated_code_info__pack_to_buffer
                     (const Google__Protobuf__GeneratedCodeInfo   *message,
                      ProtobufCBuffer     *buffer);
Google__Protobuf__GeneratedCodeInfo *
       google__protobuf__generated_code_info__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   google__protobuf__generated_code_info__free_unpacked
                     (Google__Protobuf__GeneratedCodeInfo *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Google__Protobuf__FileDescriptorSet_Closure)
                 (const Google__Protobuf__FileDescriptorSet *message,
                  void *closure_data);
typedef void (*Google__Protobuf__FileDescriptorProto_Closure)
                 (const Google__Protobuf__FileDescriptorProto *message,
                  void *closure_data);
typedef void (*Google__Protobuf__DescriptorProto__ExtensionRange_Closure)
                 (const Google__Protobuf__DescriptorProto__ExtensionRange *message,
                  void *closure_data);
typedef void (*Google__Protobuf__DescriptorProto__ReservedRange_Closure)
                 (const Google__Protobuf__DescriptorProto__ReservedRange *message,
                  void *closure_data);
typedef void (*Google__Protobuf__DescriptorProto_Closure)
                 (const Google__Protobuf__DescriptorProto *message,
                  void *closure_data);
typedef void (*Google__Protobuf__ExtensionRangeOptions_Closure)
                 (const Google__Protobuf__ExtensionRangeOptions *message,
                  void *closure_data);
typedef void (*Google__Protobuf__FieldDescriptorProto_Closure)
                 (const Google__Protobuf__FieldDescriptorProto *message,
                  void *closure_data);
typedef void (*Google__Protobuf__OneofDescriptorProto_Closure)
                 (const Google__Protobuf__OneofDescriptorProto *message,
                  void *closure_data);
typedef void (*Google__Protobuf__EnumDescriptorProto__EnumReservedRange_Closure)
                 (const Google__Protobuf__EnumDescriptorProto__EnumReservedRange *message,
                  void *closure_data);
typedef void (*Google__Protobuf__EnumDescriptorProto_Closure)
                 (const Google__Protobuf__EnumDescriptorProto *message,
                  void *closure_data);
typedef void (*Google__Protobuf__EnumValueDescriptorProto_Closure)
                 (const Google__Protobuf__EnumValueDescriptorProto *message,
                  void *closure_data);
typedef void (*Google__Protobuf__ServiceDescriptorProto_Closure)
                 (const Google__Protobuf__ServiceDescriptorProto *message,
                  void *closure_data);
typedef void (*Google__Protobuf__MethodDescriptorProto_Closure)
                 (const Google__Protobuf__MethodDescriptorProto *message,
                  void *closure_data);
typedef void (*Google__Protobuf__FileOptions_Closure)
                 (const Google__Protobuf__FileOptions *message,
                  void *closure_data);
typedef void (*Google__Protobuf__MessageOptions_Closure)
                 (const Google__Protobuf__MessageOptions *message,
                  void *closure_data);
typedef void (*Google__Protobuf__FieldOptions_Closure)
                 (const Google__Protobuf__FieldOptions *message,
                  void *closure_data);
typedef void (*Google__Protobuf__OneofOptions_Closure)
                 (const Google__Protobuf__OneofOptions *message,
                  void *closure_data);
typedef void (*Google__Protobuf__EnumOptions_Closure)
                 (const Google__Protobuf__EnumOptions *message,
                  void *closure_data);
typedef void (*Google__Protobuf__EnumValueOptions_Closure)
                 (const Google__Protobuf__EnumValueOptions *message,
                  void *closure_data);
typedef void (*Google__Protobuf__ServiceOptions_Closure)
                 (const Google__Protobuf__ServiceOptions *message,
                  void *closure_data);
typedef void (*Google__Protobuf__MethodOptions_Closure)
                 (const Google__Protobuf__MethodOptions *message,
                  void *closure_data);
typedef void (*Google__Protobuf__UninterpretedOption__NamePart_Closure)
                 (const Google__Protobuf__UninterpretedOption__NamePart *message,
                  void *closure_data);
typedef void (*Google__Protobuf__UninterpretedOption_Closure)
                 (const Google__Protobuf__UninterpretedOption *message,
                  void *closure_data);
typedef void (*Google__Protobuf__SourceCodeInfo__Location_Closure)
                 (const Google__Protobuf__SourceCodeInfo__Location *message,
                  void *closure_data);
typedef void (*Google__Protobuf__SourceCodeInfo_Closure)
                 (const Google__Protobuf__SourceCodeInfo *message,
                  void *closure_data);
typedef void (*Google__Protobuf__GeneratedCodeInfo__Annotation_Closure)
                 (const Google__Protobuf__GeneratedCodeInfo__Annotation *message,
                  void *closure_data);
typedef void (*Google__Protobuf__GeneratedCodeInfo_Closure)
                 (const Google__Protobuf__GeneratedCodeInfo *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor google__protobuf__file_descriptor_set__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__file_descriptor_proto__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__descriptor_proto__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__descriptor_proto__extension_range__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__descriptor_proto__reserved_range__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__extension_range_options__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__field_descriptor_proto__descriptor;
extern const ProtobufCEnumDescriptor    google__protobuf__field_descriptor_proto__type__descriptor;
extern const ProtobufCEnumDescriptor    google__protobuf__field_descriptor_proto__label__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__oneof_descriptor_proto__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__enum_descriptor_proto__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__enum_descriptor_proto__enum_reserved_range__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__enum_value_descriptor_proto__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__service_descriptor_proto__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__method_descriptor_proto__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__file_options__descriptor;
extern const ProtobufCEnumDescriptor    google__protobuf__file_options__optimize_mode__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__message_options__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__field_options__descriptor;
extern const ProtobufCEnumDescriptor    google__protobuf__field_options__ctype__descriptor;
extern const ProtobufCEnumDescriptor    google__protobuf__field_options__jstype__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__oneof_options__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__enum_options__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__enum_value_options__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__service_options__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__method_options__descriptor;
extern const ProtobufCEnumDescriptor    google__protobuf__method_options__idempotency_level__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__uninterpreted_option__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__uninterpreted_option__name_part__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__source_code_info__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__source_code_info__location__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__generated_code_info__descriptor;
extern const ProtobufCMessageDescriptor google__protobuf__generated_code_info__annotation__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_google_2fprotobuf_2fdescriptor_2eproto__INCLUDED */
