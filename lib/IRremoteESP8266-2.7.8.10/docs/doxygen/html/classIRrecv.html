<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IRremoteESP8266: IRrecv Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IRremoteESP8266
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classIRrecv-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IRrecv Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for receiving IR messages.  
 <a href="classIRrecv.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="IRrecv_8h_source.html">IRrecv.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for IRrecv:</div>
<div class="dyncontent">
<div class="center"><img src="classIRrecv__coll__graph.png" border="0" usemap="#IRrecv_coll__map" alt="Collaboration graph"/></div>
<map name="IRrecv_coll__map" id="IRrecv_coll__map">
<area shape="rect" title="Class for receiving IR messages." alt="" coords="20,95,83,121"/>
<area shape="rect" href="structirparams__t.html" title="Information for the interrupt handler." alt="" coords="5,5,97,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8fe4d26ef1f863db1db9994fed5fc209"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a8fe4d26ef1f863db1db9994fed5fc209">IRrecv</a> (const uint16_t recvpin, const uint16_t bufsize=<a class="el" href="IRrecv_8h.html#aadfa37def10a1adeaf2cf4c09d7504e3">kRawBuf</a>, const uint8_t timeout=<a class="el" href="IRrecv_8h.html#ad37e9659aaef29c541802d9759e0ab7b">kTimeoutMs</a>, const bool save_buffer=false, const uint8_t timer_num=<a class="el" href="IRrecv_8h.html#a80a2d3445a1752d18caf307d7677b709">kDefaultESP32Timer</a>)</td></tr>
<tr class="memdesc:a8fe4d26ef1f863db1db9994fed5fc209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class constructor Args:  <a href="classIRrecv.html#a8fe4d26ef1f863db1db9994fed5fc209">More...</a><br /></td></tr>
<tr class="separator:a8fe4d26ef1f863db1db9994fed5fc209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb1bcc1c1a3184294dd35c8f6f758b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a3bb1bcc1c1a3184294dd35c8f6f758b1">IRrecv</a> (const uint16_t recvpin, const uint16_t bufsize=<a class="el" href="IRrecv_8h.html#aadfa37def10a1adeaf2cf4c09d7504e3">kRawBuf</a>, const uint8_t timeout=<a class="el" href="IRrecv_8h.html#ad37e9659aaef29c541802d9759e0ab7b">kTimeoutMs</a>, const bool save_buffer=false)</td></tr>
<tr class="separator:a3bb1bcc1c1a3184294dd35c8f6f758b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d4cca5e350177cb0922842dda1eb5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a87d4cca5e350177cb0922842dda1eb5b">~IRrecv</a> (void)</td></tr>
<tr class="memdesc:a87d4cca5e350177cb0922842dda1eb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class destructor Cleans up after the object is no longer needed. e.g. Frees up all memory used by the various buffers, and disables any timers or interrupts used.  <a href="classIRrecv.html#a87d4cca5e350177cb0922842dda1eb5b">More...</a><br /></td></tr>
<tr class="separator:a87d4cca5e350177cb0922842dda1eb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa091c449db70c65fd0221669df7438ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#aa091c449db70c65fd0221669df7438ea">setTolerance</a> (const uint8_t percent=<a class="el" href="IRrecv_8h.html#a7884008b3a738dfc7bd8658655e10272">kTolerance</a>)</td></tr>
<tr class="memdesc:aa091c449db70c65fd0221669df7438ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the base tolerance percentage for matching incoming IR messages.  <a href="classIRrecv.html#aa091c449db70c65fd0221669df7438ea">More...</a><br /></td></tr>
<tr class="separator:aa091c449db70c65fd0221669df7438ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144f64da3b44708394c06b0fbefb6347"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a144f64da3b44708394c06b0fbefb6347">getTolerance</a> (void)</td></tr>
<tr class="memdesc:a144f64da3b44708394c06b0fbefb6347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the base tolerance percentage for matching incoming IR messages.  <a href="classIRrecv.html#a144f64da3b44708394c06b0fbefb6347">More...</a><br /></td></tr>
<tr class="separator:a144f64da3b44708394c06b0fbefb6347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa5c07a8b46f8fbb982f996cc1f9f4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#aeaa5c07a8b46f8fbb982f996cc1f9f4b">decode</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, <a class="el" href="structirparams__t.html">irparams_t</a> *save=NULL, uint8_t max_skip=0, uint16_t noise_floor=0)</td></tr>
<tr class="memdesc:aeaa5c07a8b46f8fbb982f996cc1f9f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the received IR message. If the interrupt state is saved, we will immediately resume waiting for the next IR message to avoid missing messages.  <a href="classIRrecv.html#aeaa5c07a8b46f8fbb982f996cc1f9f4b">More...</a><br /></td></tr>
<tr class="separator:aeaa5c07a8b46f8fbb982f996cc1f9f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c05ec6d8f3dbfb75f21f3b4fe7be3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a52c05ec6d8f3dbfb75f21f3b4fe7be3d">enableIRIn</a> (const bool pullup=false)</td></tr>
<tr class="memdesc:a52c05ec6d8f3dbfb75f21f3b4fe7be3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up and (re)start the IR capture mechanism.  <a href="classIRrecv.html#a52c05ec6d8f3dbfb75f21f3b4fe7be3d">More...</a><br /></td></tr>
<tr class="separator:a52c05ec6d8f3dbfb75f21f3b4fe7be3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4a719e756ad78c7dd47186f8bef087"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a9f4a719e756ad78c7dd47186f8bef087">disableIRIn</a> (void)</td></tr>
<tr class="memdesc:a9f4a719e756ad78c7dd47186f8bef087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop collection of any received IR data. Disable any timers and interrupts.  <a href="classIRrecv.html#a9f4a719e756ad78c7dd47186f8bef087">More...</a><br /></td></tr>
<tr class="separator:a9f4a719e756ad78c7dd47186f8bef087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5beb7348d807d8d98ae929d005510e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a6b5beb7348d807d8d98ae929d005510e">resume</a> (void)</td></tr>
<tr class="memdesc:a6b5beb7348d807d8d98ae929d005510e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume collection of received IR data.  <a href="classIRrecv.html#a6b5beb7348d807d8d98ae929d005510e">More...</a><br /></td></tr>
<tr class="separator:a6b5beb7348d807d8d98ae929d005510e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ab02ea6823ccf18d1f6be87ca1b92e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a69ab02ea6823ccf18d1f6be87ca1b92e">getBufSize</a> (void)</td></tr>
<tr class="memdesc:a69ab02ea6823ccf18d1f6be87ca1b92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the maximum number of entries possible in the capture buffer. i.e. It's size.  <a href="classIRrecv.html#a69ab02ea6823ccf18d1f6be87ca1b92e">More...</a><br /></td></tr>
<tr class="separator:a69ab02ea6823ccf18d1f6be87ca1b92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02693553aad1decd67bdae60402e48bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a02693553aad1decd67bdae60402e48bf">setUnknownThreshold</a> (const uint16_t length)</td></tr>
<tr class="memdesc:a02693553aad1decd67bdae60402e48bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum length we will consider for reporting UNKNOWN message types.  <a href="classIRrecv.html#a02693553aad1decd67bdae60402e48bf">More...</a><br /></td></tr>
<tr class="separator:a02693553aad1decd67bdae60402e48bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc218dae714ab189a3da4fff269cdaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a8bc218dae714ab189a3da4fff269cdaa">match</a> (const uint32_t measured, const uint32_t desired, const uint8_t tolerance=<a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a>, const uint16_t delta=0)</td></tr>
<tr class="memdesc:a8bc218dae714ab189a3da4fff269cdaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if we match a pulse(measured) with the desired within +/-tolerance percent and/or +/- a fixed delta range.  <a href="classIRrecv.html#a8bc218dae714ab189a3da4fff269cdaa">More...</a><br /></td></tr>
<tr class="separator:a8bc218dae714ab189a3da4fff269cdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78ef12b8194db5d3cb5a2605d29830d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#ae78ef12b8194db5d3cb5a2605d29830d">matchMark</a> (const uint32_t measured, const uint32_t desired, const uint8_t tolerance=<a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a>, const int16_t excess=<a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a>)</td></tr>
<tr class="memdesc:ae78ef12b8194db5d3cb5a2605d29830d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if we match a mark signal(measured) with the desired within +/-tolerance percent, after an expected is excess is added.  <a href="classIRrecv.html#ae78ef12b8194db5d3cb5a2605d29830d">More...</a><br /></td></tr>
<tr class="separator:ae78ef12b8194db5d3cb5a2605d29830d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd363e8b2edee2ed3c473349ecc58fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a9fd363e8b2edee2ed3c473349ecc58fc">matchSpace</a> (const uint32_t measured, const uint32_t desired, const uint8_t tolerance=<a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a>, const int16_t excess=<a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a>)</td></tr>
<tr class="memdesc:a9fd363e8b2edee2ed3c473349ecc58fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if we match a space signal(measured) with the desired within +/-tolerance percent, after an expected is excess is removed.  <a href="classIRrecv.html#a9fd363e8b2edee2ed3c473349ecc58fc">More...</a><br /></td></tr>
<tr class="separator:a9fd363e8b2edee2ed3c473349ecc58fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0b4221970de0d027b5ae99648fa1c003"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a0b4221970de0d027b5ae99648fa1c003">_validTolerance</a> (const uint8_t percentage)</td></tr>
<tr class="memdesc:a0b4221970de0d027b5ae99648fa1c003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the tolerance percentage into something valid.  <a href="classIRrecv.html#a0b4221970de0d027b5ae99648fa1c003">More...</a><br /></td></tr>
<tr class="separator:a0b4221970de0d027b5ae99648fa1c003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab017a0f9256954bb7d943e3c6b7e31bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#ab017a0f9256954bb7d943e3c6b7e31bf">copyIrParams</a> (volatile <a class="el" href="structirparams__t.html">irparams_t</a> *src, <a class="el" href="structirparams__t.html">irparams_t</a> *dst)</td></tr>
<tr class="memdesc:ab017a0f9256954bb7d943e3c6b7e31bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of the interrupt state &amp; buffer data. Needed because irparams is marked as volatile, thus memcpy() isn't allowed. Only call this when you know the interrupt handlers won't modify anything. i.e. In kStopState.  <a href="classIRrecv.html#ab017a0f9256954bb7d943e3c6b7e31bf">More...</a><br /></td></tr>
<tr class="separator:ab017a0f9256954bb7d943e3c6b7e31bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7347c72b14d9f2f20f65bcf235ab3dc"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#ad7347c72b14d9f2f20f65bcf235ab3dc">compare</a> (const uint16_t oldval, const uint16_t newval)</td></tr>
<tr class="memdesc:ad7347c72b14d9f2f20f65bcf235ab3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two tick values.  <a href="classIRrecv.html#ad7347c72b14d9f2f20f65bcf235ab3dc">More...</a><br /></td></tr>
<tr class="separator:ad7347c72b14d9f2f20f65bcf235ab3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08e50c5eec10c0095157f4bdd4051c8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#ac08e50c5eec10c0095157f4bdd4051c8">ticksLow</a> (const uint32_t usecs, const uint8_t tolerance=<a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a>, const uint16_t delta=0)</td></tr>
<tr class="memdesc:ac08e50c5eec10c0095157f4bdd4051c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the lower bound of the nr. of ticks.  <a href="classIRrecv.html#ac08e50c5eec10c0095157f4bdd4051c8">More...</a><br /></td></tr>
<tr class="separator:ac08e50c5eec10c0095157f4bdd4051c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573dbb20695f2ffc808623df8c36280c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a573dbb20695f2ffc808623df8c36280c">ticksHigh</a> (const uint32_t usecs, const uint8_t tolerance=<a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a>, const uint16_t delta=0)</td></tr>
<tr class="memdesc:a573dbb20695f2ffc808623df8c36280c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the upper bound of the nr. of ticks.  <a href="classIRrecv.html#a573dbb20695f2ffc808623df8c36280c">More...</a><br /></td></tr>
<tr class="separator:a573dbb20695f2ffc808623df8c36280c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bfd4ff689c7563c65c4e6e8c58187a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#ae7bfd4ff689c7563c65c4e6e8c58187a">matchAtLeast</a> (const uint32_t measured, const uint32_t desired, const uint8_t tolerance=<a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a>, const uint16_t delta=0)</td></tr>
<tr class="memdesc:ae7bfd4ff689c7563c65c4e6e8c58187a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if we match a pulse(measured) of at least desired within tolerance percent and/or a fixed delta margin.  <a href="classIRrecv.html#ae7bfd4ff689c7563c65c4e6e8c58187a">More...</a><br /></td></tr>
<tr class="separator:ae7bfd4ff689c7563c65c4e6e8c58187a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b300fe6fdff58324525e8208be3024"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#af0b300fe6fdff58324525e8208be3024">_matchGeneric</a> (volatile uint16_t *data_ptr, uint64_t *result_bits_ptr, uint8_t *result_ptr, const bool use_bits, const uint16_t remaining, const uint16_t required, const uint16_t hdrmark, const uint32_t hdrspace, const uint16_t onemark, const uint32_t onespace, const uint16_t zeromark, const uint32_t zerospace, const uint16_t footermark, const uint32_t footerspace, const bool atleast=false, const uint8_t tolerance=<a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a>, const int16_t excess=<a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a>, const bool MSBfirst=true)</td></tr>
<tr class="memdesc:af0b300fe6fdff58324525e8208be3024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match &amp; decode a generic/typical IR message. The data is stored in result_bits_ptr or result_bytes_ptr depending on flag <code>use_bits</code>.  <a href="classIRrecv.html#af0b300fe6fdff58324525e8208be3024">More...</a><br /></td></tr>
<tr class="separator:af0b300fe6fdff58324525e8208be3024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5361439cb69b1069553544e486502d2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatch__result__t.html">match_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a5361439cb69b1069553544e486502d2e">matchData</a> (volatile uint16_t *data_ptr, const uint16_t nbits, const uint16_t onemark, const uint32_t onespace, const uint16_t zeromark, const uint32_t zerospace, const uint8_t tolerance=<a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a>, const int16_t excess=<a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a>, const bool MSBfirst=true)</td></tr>
<tr class="memdesc:a5361439cb69b1069553544e486502d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match &amp; decode the typical data section of an IR message. The data value is stored in the least significant bits reguardless of the bit ordering requested.  <a href="classIRrecv.html#a5361439cb69b1069553544e486502d2e">More...</a><br /></td></tr>
<tr class="separator:a5361439cb69b1069553544e486502d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2c9bc4c4e5741cfac7468126bf8ca6"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#adc2c9bc4c4e5741cfac7468126bf8ca6">matchBytes</a> (volatile uint16_t *data_ptr, uint8_t *result_ptr, const uint16_t remaining, const uint16_t nbytes, const uint16_t onemark, const uint32_t onespace, const uint16_t zeromark, const uint32_t zerospace, const uint8_t tolerance=<a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a>, const int16_t excess=<a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a>, const bool MSBfirst=true)</td></tr>
<tr class="memdesc:adc2c9bc4c4e5741cfac7468126bf8ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match &amp; decode the typical data section of an IR message. The bytes are stored at result_ptr. The first byte in the result equates to the first byte encountered, and so on.  <a href="classIRrecv.html#adc2c9bc4c4e5741cfac7468126bf8ca6">More...</a><br /></td></tr>
<tr class="separator:adc2c9bc4c4e5741cfac7468126bf8ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab783f52acc2ff4052313d6947563e4fd"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#ab783f52acc2ff4052313d6947563e4fd">matchGeneric</a> (volatile uint16_t *data_ptr, uint64_t *result_ptr, const uint16_t remaining, const uint16_t nbits, const uint16_t hdrmark, const uint32_t hdrspace, const uint16_t onemark, const uint32_t onespace, const uint16_t zeromark, const uint32_t zerospace, const uint16_t footermark, const uint32_t footerspace, const bool atleast=false, const uint8_t tolerance=<a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a>, const int16_t excess=<a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a>, const bool MSBfirst=true)</td></tr>
<tr class="memdesc:ab783f52acc2ff4052313d6947563e4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match &amp; decode a generic/typical &lt;= 64bit IR message. The data is stored at result_ptr.  <a href="classIRrecv.html#ab783f52acc2ff4052313d6947563e4fd">More...</a><br /></td></tr>
<tr class="separator:ab783f52acc2ff4052313d6947563e4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4448c1658383962d735353352987c9aa"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a4448c1658383962d735353352987c9aa">matchGeneric</a> (volatile uint16_t *data_ptr, uint8_t *result_ptr, const uint16_t remaining, const uint16_t nbits, const uint16_t hdrmark, const uint32_t hdrspace, const uint16_t onemark, const uint32_t onespace, const uint16_t zeromark, const uint32_t zerospace, const uint16_t footermark, const uint32_t footerspace, const bool atleast=false, const uint8_t tolerance=<a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a>, const int16_t excess=<a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a>, const bool MSBfirst=true)</td></tr>
<tr class="memdesc:a4448c1658383962d735353352987c9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match &amp; decode a generic/typical &gt; 64bit IR message. The bytes are stored at result_ptr. The first byte in the result equates to the first byte encountered, and so on.  <a href="classIRrecv.html#a4448c1658383962d735353352987c9aa">More...</a><br /></td></tr>
<tr class="separator:a4448c1658383962d735353352987c9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4582d75ef1d11aee35fce86c38dcccf0"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a4582d75ef1d11aee35fce86c38dcccf0">matchGenericConstBitTime</a> (volatile uint16_t *data_ptr, uint64_t *result_ptr, const uint16_t remaining, const uint16_t nbits, const uint16_t hdrmark, const uint32_t hdrspace, const uint16_t one, const uint32_t zero, const uint16_t footermark, const uint32_t footerspace, const bool atleast=false, const uint8_t tolerance=<a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a>, const int16_t excess=<a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a>, const bool MSBfirst=true)</td></tr>
<tr class="memdesc:a4582d75ef1d11aee35fce86c38dcccf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match &amp; decode a generic/typical constant bit time &lt;= 64bit IR message. The data is stored at result_ptr.  <a href="classIRrecv.html#a4582d75ef1d11aee35fce86c38dcccf0">More...</a><br /></td></tr>
<tr class="separator:a4582d75ef1d11aee35fce86c38dcccf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44403411a217eb8ea75271575f8ab83"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#ab44403411a217eb8ea75271575f8ab83">matchManchesterData</a> (volatile const uint16_t *data_ptr, uint64_t *result_ptr, const uint16_t remaining, const uint16_t nbits, const uint16_t half_period, const uint16_t starting_balance=0, const uint8_t tolerance=<a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a>, const int16_t excess=<a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a>, const bool MSBfirst=true, const bool GEThomas=true)</td></tr>
<tr class="memdesc:ab44403411a217eb8ea75271575f8ab83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match &amp; decode a Manchester Code data (&lt;= 64bits.  <a href="classIRrecv.html#ab44403411a217eb8ea75271575f8ab83">More...</a><br /></td></tr>
<tr class="separator:ab44403411a217eb8ea75271575f8ab83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade70777ad0e047e11b99b03d8f5e3728"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#ade70777ad0e047e11b99b03d8f5e3728">matchManchester</a> (volatile const uint16_t *data_ptr, uint64_t *result_ptr, const uint16_t remaining, const uint16_t nbits, const uint16_t hdrmark, const uint32_t hdrspace, const uint16_t clock_period, const uint16_t footermark, const uint32_t footerspace, const bool atleast=false, const uint8_t tolerance=<a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a>, const int16_t excess=<a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a>, const bool MSBfirst=true, const bool GEThomas=true)</td></tr>
<tr class="memdesc:ade70777ad0e047e11b99b03d8f5e3728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match &amp; decode a Manchester Code &lt;= 64bit IR message. The data is stored at result_ptr.  <a href="classIRrecv.html#ade70777ad0e047e11b99b03d8f5e3728">More...</a><br /></td></tr>
<tr class="separator:ade70777ad0e047e11b99b03d8f5e3728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae833bdb8fccc676043fc4ccae432fab1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#ae833bdb8fccc676043fc4ccae432fab1">crudeNoiseFilter</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, const uint16_t floor=0)</td></tr>
<tr class="memdesc:ae833bdb8fccc676043fc4ccae432fab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove or merge pulses in the capture buffer that are too short.  <a href="classIRrecv.html#ae833bdb8fccc676043fc4ccae432fab1">More...</a><br /></td></tr>
<tr class="separator:ae833bdb8fccc676043fc4ccae432fab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c15fbfa7936ca474712a1953911fd06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a7c15fbfa7936ca474712a1953911fd06">decodeHash</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results)</td></tr>
<tr class="memdesc:a7c15fbfa7936ca474712a1953911fd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode any arbitrary IR message into a 32-bit code value. Instead of decoding using a standard encoding scheme (e.g. Sony, NEC, RC5), the code is hashed to a 32-bit value.  <a href="classIRrecv.html#a7c15fbfa7936ca474712a1953911fd06">More...</a><br /></td></tr>
<tr class="separator:a7c15fbfa7936ca474712a1953911fd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b844f80df7f64edf9ce9cc189ac5b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a52b844f80df7f64edf9ce9cc189ac5b9">decodeNEC</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a65e03baf646815b4b02f943bdd74a097">kNECBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a52b844f80df7f64edf9ce9cc189ac5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied NEC (Renesas) message. Status: STABLE / Known good.  <a href="classIRrecv.html#a52b844f80df7f64edf9ce9cc189ac5b9">More...</a><br /></td></tr>
<tr class="separator:a52b844f80df7f64edf9ce9cc189ac5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f12dc000a6e7b75ea8680fd48fc487"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a94f12dc000a6e7b75ea8680fd48fc487">decodeArgo</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a351efcd1805c87bd338de81dab3f8fb2">kArgoBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a94f12dc000a6e7b75ea8680fd48fc487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Argo message. Status: BETA / Probably works.  <a href="classIRrecv.html#a94f12dc000a6e7b75ea8680fd48fc487">More...</a><br /></td></tr>
<tr class="separator:a94f12dc000a6e7b75ea8680fd48fc487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03227955cf7d1d00c1620c55d7f9f18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#ab03227955cf7d1d00c1620c55d7f9f18">decodeSony</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a6f0794107a7643e0bec8de6de9e7621b">kSonyMinBits</a>, const bool strict=false)</td></tr>
<tr class="memdesc:ab03227955cf7d1d00c1620c55d7f9f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Sony/SIRC message. Status: STABLE / Should be working. strict mode is ALPHA / Untested.  <a href="classIRrecv.html#ab03227955cf7d1d00c1620c55d7f9f18">More...</a><br /></td></tr>
<tr class="separator:ab03227955cf7d1d00c1620c55d7f9f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201a5a78f43c2ac216fae4a2ba4d14ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a201a5a78f43c2ac216fae4a2ba4d14ec">decodeSanyoLC7461</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#ad067db05b273337e0df38d529094c9e8">kSanyoLC7461Bits</a>, bool strict=true)</td></tr>
<tr class="memdesc:a201a5a78f43c2ac216fae4a2ba4d14ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied SANYO LC7461 message. Status: BETA / Probably works.  <a href="classIRrecv.html#a201a5a78f43c2ac216fae4a2ba4d14ec">More...</a><br /></td></tr>
<tr class="separator:a201a5a78f43c2ac216fae4a2ba4d14ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efe3be80f0ebef3ff94ed0e56c5c52a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a6efe3be80f0ebef3ff94ed0e56c5c52a">decodeMitsubishi</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#abd2187340d0b94996136081413e2ad22">kMitsubishiBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a6efe3be80f0ebef3ff94ed0e56c5c52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Mitsubishi 16-bit message. Status: STABLE / Working.  <a href="classIRrecv.html#a6efe3be80f0ebef3ff94ed0e56c5c52a">More...</a><br /></td></tr>
<tr class="separator:a6efe3be80f0ebef3ff94ed0e56c5c52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9514197850491a5b8c30ae9ffc89d895"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a9514197850491a5b8c30ae9ffc89d895">decodeMitsubishi2</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#abd2187340d0b94996136081413e2ad22">kMitsubishiBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a9514197850491a5b8c30ae9ffc89d895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied second variation of a Mitsubishi 16-bit message. Status: STABLE / Working.  <a href="classIRrecv.html#a9514197850491a5b8c30ae9ffc89d895">More...</a><br /></td></tr>
<tr class="separator:a9514197850491a5b8c30ae9ffc89d895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942c5f41df5cbff32a8b7703673cb621"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a942c5f41df5cbff32a8b7703673cb621">decodeMitsubishiAC</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a911a47148656b26da2e094a7ced1fc8b">kMitsubishiACBits</a>, const bool strict=false)</td></tr>
<tr class="memdesc:a942c5f41df5cbff32a8b7703673cb621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Mitsubish 144-bit A/C message. Status: BETA / Probably works.  <a href="classIRrecv.html#a942c5f41df5cbff32a8b7703673cb621">More...</a><br /></td></tr>
<tr class="separator:a942c5f41df5cbff32a8b7703673cb621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b3ee57dbdf762a0e305ddd43eec629"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a87b3ee57dbdf762a0e305ddd43eec629">decodeMitsubishi136</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#aa19f0122b2f906e5473a6ea232c38974">kMitsubishi136Bits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a87b3ee57dbdf762a0e305ddd43eec629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Mitsubishi 136-bit A/C message. (MITSUBISHI136) Status: STABLE / Reported as working.  <a href="classIRrecv.html#a87b3ee57dbdf762a0e305ddd43eec629">More...</a><br /></td></tr>
<tr class="separator:a87b3ee57dbdf762a0e305ddd43eec629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0690ff3cb5a5cdcdb6a514bb7bf0cdd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#ae0690ff3cb5a5cdcdb6a514bb7bf0cdd">decodeMitsubishi112</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#ae8349abe183be965e3d051cb736773a8">kMitsubishi112Bits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:ae0690ff3cb5a5cdcdb6a514bb7bf0cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Mitsubishi/TCL 112-bit A/C message. (MITSUBISHI112, TCL112AC) Status: STABLE / Reported as working.  <a href="classIRrecv.html#ae0690ff3cb5a5cdcdb6a514bb7bf0cdd">More...</a><br /></td></tr>
<tr class="separator:ae0690ff3cb5a5cdcdb6a514bb7bf0cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9cedf79793806df4cc5376710781bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#aef9cedf79793806df4cc5376710781bc">decodeMitsubishiHeavy</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#ab973b35583dabc7e04b12018fac04cc9">kMitsubishiHeavy152Bits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:aef9cedf79793806df4cc5376710781bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Mitsubishi Heavy Industries A/C message. Status: BETA / Appears to be working. Needs testing against a real device.  <a href="classIRrecv.html#aef9cedf79793806df4cc5376710781bc">More...</a><br /></td></tr>
<tr class="separator:aef9cedf79793806df4cc5376710781bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e32daaa903a8e42dad7faaf405b33dc"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a8e32daaa903a8e42dad7faaf405b33dc">getRClevel</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t *offset, uint16_t *used, uint16_t bitTime, const uint8_t tolerance=<a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a>, const int16_t excess=<a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a>, const uint16_t delta=0, const uint8_t maxwidth=3)</td></tr>
<tr class="memdesc:a8e32daaa903a8e42dad7faaf405b33dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets one undecoded level at a time from the raw buffer. The RC5/6 decoding is easier if the data is broken into time intervals. E.g. if the buffer has MARK for 2 time intervals and SPACE for 1, successive calls to getRClevel will return MARK, MARK, SPACE. offset and used are updated to keep track of the current position.  <a href="classIRrecv.html#a8e32daaa903a8e42dad7faaf405b33dc">More...</a><br /></td></tr>
<tr class="separator:a8e32daaa903a8e42dad7faaf405b33dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab9dffbeceee514520fababd0e721bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#adab9dffbeceee514520fababd0e721bd">decodeRC5</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#abec3ebb217126560e824fa8b66d495bc">kRC5XBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:adab9dffbeceee514520fababd0e721bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied RC-5/RC5X message. Status: RC-5 (stable), RC-5X (alpha)  <a href="classIRrecv.html#adab9dffbeceee514520fababd0e721bd">More...</a><br /></td></tr>
<tr class="separator:adab9dffbeceee514520fababd0e721bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67316499ef37db82e3b3ecaac25c5980"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a67316499ef37db82e3b3ecaac25c5980">decodeRC6</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a84a6d3e15e98f7a4917d252d5665534a">kRC6Mode0Bits</a>, const bool strict=false)</td></tr>
<tr class="memdesc:a67316499ef37db82e3b3ecaac25c5980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied RC6 message. Status: Stable.  <a href="classIRrecv.html#a67316499ef37db82e3b3ecaac25c5980">More...</a><br /></td></tr>
<tr class="separator:a67316499ef37db82e3b3ecaac25c5980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7bf769cb5bebf174e852e4b0b08cf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a0e7bf769cb5bebf174e852e4b0b08cf3">decodeRCMM</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a2bfaf393c2d77a594f2a0a5a763e84f5">kRCMMBits</a>, const bool strict=false)</td></tr>
<tr class="memdesc:a0e7bf769cb5bebf174e852e4b0b08cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a Philips RC-MM packet (between 12 &amp; 32 bits) if possible. Status: STABLE / Should be working.  <a href="classIRrecv.html#a0e7bf769cb5bebf174e852e4b0b08cf3">More...</a><br /></td></tr>
<tr class="separator:a0e7bf769cb5bebf174e852e4b0b08cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dd5f24d28576c6db03cc463bd0a865"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#aa8dd5f24d28576c6db03cc463bd0a865">decodePanasonic</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#aa148f54492be1cf8a8b285a96861a0b7">kPanasonicBits</a>, const bool strict=false, const uint32_t manufacturer=<a class="el" href="IRremoteESP8266_8h.html#a1dd1a9799e5d20d39e82ff678bf07b47">kPanasonicManufacturer</a>)</td></tr>
<tr class="memdesc:aa8dd5f24d28576c6db03cc463bd0a865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Panasonic message. Status: STABLE / Should be working.  <a href="classIRrecv.html#aa8dd5f24d28576c6db03cc463bd0a865">More...</a><br /></td></tr>
<tr class="separator:aa8dd5f24d28576c6db03cc463bd0a865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe70015c36b1477a5de0c193163e13a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#afe70015c36b1477a5de0c193163e13a7">decodeLG</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a256bd6093034b3e4c33324680f3a7102">kLgBits</a>, const bool strict=false)</td></tr>
<tr class="memdesc:afe70015c36b1477a5de0c193163e13a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied LG message. Status: STABLE / Working.  <a href="classIRrecv.html#afe70015c36b1477a5de0c193163e13a7">More...</a><br /></td></tr>
<tr class="separator:afe70015c36b1477a5de0c193163e13a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94545c6a8da027b9cb0e23ecba4c29d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a94545c6a8da027b9cb0e23ecba4c29d8">decodeInax</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#af8441f25b32d113096adeaff331c126a">kInaxBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a94545c6a8da027b9cb0e23ecba4c29d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Inax Toilet message. Status: Stable / Known working.  <a href="classIRrecv.html#a94545c6a8da027b9cb0e23ecba4c29d8">More...</a><br /></td></tr>
<tr class="separator:a94545c6a8da027b9cb0e23ecba4c29d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ab71efc223a418e9630d8421f44bc9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a25ab71efc223a418e9630d8421f44bc9">decodeJVC</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a7c28467832e7480864a6be0ce87c608f">kJvcBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a25ab71efc223a418e9630d8421f44bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied JVC message. Status: Stable / Known working.  <a href="classIRrecv.html#a25ab71efc223a418e9630d8421f44bc9">More...</a><br /></td></tr>
<tr class="separator:a25ab71efc223a418e9630d8421f44bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b6cf177364faf11b9a076dd2025eec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a18b6cf177364faf11b9a076dd2025eec">decodeSAMSUNG</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a7c1c015cce09284799cbf5a2f21ee170">kSamsungBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a18b6cf177364faf11b9a076dd2025eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Samsung 32-bit message. Status: STABLE.  <a href="classIRrecv.html#a18b6cf177364faf11b9a076dd2025eec">More...</a><br /></td></tr>
<tr class="separator:a18b6cf177364faf11b9a076dd2025eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290a9e6a0b12ef1fe02a92a456c8ad57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a290a9e6a0b12ef1fe02a92a456c8ad57">decodeSamsung36</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a5e1e6f30a41f0d94652429a9e1034179">kSamsung36Bits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a290a9e6a0b12ef1fe02a92a456c8ad57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Samsung36 message. Status: Alpha / Experimental.  <a href="classIRrecv.html#a290a9e6a0b12ef1fe02a92a456c8ad57">More...</a><br /></td></tr>
<tr class="separator:a290a9e6a0b12ef1fe02a92a456c8ad57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae779c76ebd0f3cd1fc13abaa55f80d67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#ae779c76ebd0f3cd1fc13abaa55f80d67">decodeSamsungAC</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#adebe85ab48eb876ec15daacca246797c">kSamsungAcBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:ae779c76ebd0f3cd1fc13abaa55f80d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Samsung A/C message. Status: Stable / Known to be working.  <a href="classIRrecv.html#ae779c76ebd0f3cd1fc13abaa55f80d67">More...</a><br /></td></tr>
<tr class="separator:ae779c76ebd0f3cd1fc13abaa55f80d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66289f6a462557ad26e6c0a64f36cf02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a66289f6a462557ad26e6c0a64f36cf02">decodeWhynter</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a4553f6670e241a67104d45216a4ebd98">kWhynterBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a66289f6a462557ad26e6c0a64f36cf02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Whynter message. Status: STABLE / Working. Strict mode is ALPHA.  <a href="classIRrecv.html#a66289f6a462557ad26e6c0a64f36cf02">More...</a><br /></td></tr>
<tr class="separator:a66289f6a462557ad26e6c0a64f36cf02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964af7e72e2133688f0596c718cb98ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a964af7e72e2133688f0596c718cb98ca">decodeCOOLIX</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#aed48c68a637e4b45b80bbf4964ea79f9">kCoolixBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a964af7e72e2133688f0596c718cb98ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Coolix A/C message. Status: STABLE / Known Working.  <a href="classIRrecv.html#a964af7e72e2133688f0596c718cb98ca">More...</a><br /></td></tr>
<tr class="separator:a964af7e72e2133688f0596c718cb98ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1bd1c817cb43bc3755126191b7f4a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a0b1bd1c817cb43bc3755126191b7f4a2">decodeDenon</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a29160117e25f3dfc1cb899a4a53bc238">kDenonBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a0b1bd1c817cb43bc3755126191b7f4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Delonghi A/C message. Status: STABLE / Should work fine.  <a href="classIRrecv.html#a0b1bd1c817cb43bc3755126191b7f4a2">More...</a><br /></td></tr>
<tr class="separator:a0b1bd1c817cb43bc3755126191b7f4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851776d9178aeb706d9a1abd3f254e31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a851776d9178aeb706d9a1abd3f254e31">decodeDISH</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#aea0cc15e1c7a6edcd6b60d9ac62d4831">kDishBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a851776d9178aeb706d9a1abd3f254e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied DISH NETWORK message. Status: ALPHA (untested and unconfirmed.)  <a href="classIRrecv.html#a851776d9178aeb706d9a1abd3f254e31">More...</a><br /></td></tr>
<tr class="separator:a851776d9178aeb706d9a1abd3f254e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3390d63ba21a835d7c74c261532a22a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a3390d63ba21a835d7c74c261532a22a7">decodeSharp</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a8a74f9d7cec751cc0945fd89fa6237ae">kSharpBits</a>, const bool strict=true, const bool expansion=true)</td></tr>
<tr class="memdesc:a3390d63ba21a835d7c74c261532a22a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Sharp message. Status: STABLE / Working fine.  <a href="classIRrecv.html#a3390d63ba21a835d7c74c261532a22a7">More...</a><br /></td></tr>
<tr class="separator:a3390d63ba21a835d7c74c261532a22a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9b920079f783e236f8a938e20b9743"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a8a9b920079f783e236f8a938e20b9743">decodeSharpAc</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a6c106a982acced5d8aeef98644002ca2">kSharpAcBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a8a9b920079f783e236f8a938e20b9743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Sharp A/C message. Status: STABLE / Known working.  <a href="classIRrecv.html#a8a9b920079f783e236f8a938e20b9743">More...</a><br /></td></tr>
<tr class="separator:a8a9b920079f783e236f8a938e20b9743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d678376a4c0f8ea953474a6f5ef9d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#aa4d678376a4c0f8ea953474a6f5ef9d2">decodeAiwaRCT501</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a9078adf040d21c9c3eb10ed69f9dced6">kAiwaRcT501Bits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:aa4d678376a4c0f8ea953474a6f5ef9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Aiwa RC T501 message. Status: BETA / Should work.  <a href="classIRrecv.html#aa4d678376a4c0f8ea953474a6f5ef9d2">More...</a><br /></td></tr>
<tr class="separator:aa4d678376a4c0f8ea953474a6f5ef9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcbf5fc07d7e37d7724acc37bb5f592"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#abbcbf5fc07d7e37d7724acc37bb5f592">decodeNikai</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a9fce002592f9e2488b1b717d0b1a6a40">kNikaiBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:abbcbf5fc07d7e37d7724acc37bb5f592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Nikai message. Status: STABLE / Working.  <a href="classIRrecv.html#abbcbf5fc07d7e37d7724acc37bb5f592">More...</a><br /></td></tr>
<tr class="separator:abbcbf5fc07d7e37d7724acc37bb5f592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3bfcc6767484151dee758bcf94fb0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a6f3bfcc6767484151dee758bcf94fb0b">decodeMagiQuest</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#ad756bfec6eabbe2ac10b7847f87fb751">kMagiquestBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a6f3bfcc6767484151dee758bcf94fb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied MagiQuest message. Status: Beta / Should work.  <a href="classIRrecv.html#a6f3bfcc6767484151dee758bcf94fb0b">More...</a><br /></td></tr>
<tr class="separator:a6f3bfcc6767484151dee758bcf94fb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac82f20b48b2d71ee07eb392578b226"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a0ac82f20b48b2d71ee07eb392578b226">decodeKelvinator</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#acfa71cb3caf4964829bb1f557dee5b86">kKelvinatorBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a0ac82f20b48b2d71ee07eb392578b226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Kelvinator message. Status: STABLE / Known working.  <a href="classIRrecv.html#a0ac82f20b48b2d71ee07eb392578b226">More...</a><br /></td></tr>
<tr class="separator:a0ac82f20b48b2d71ee07eb392578b226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141f0de9f4cae8daeb025aff3904ecaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a141f0de9f4cae8daeb025aff3904ecaa">decodeDaikin</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a657f8e60bc1f896d4a46ec101c289485">kDaikinBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a141f0de9f4cae8daeb025aff3904ecaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Daikin 280-bit message. (DAIKIN) Status: STABLE / Reported as working.  <a href="classIRrecv.html#a141f0de9f4cae8daeb025aff3904ecaa">More...</a><br /></td></tr>
<tr class="separator:a141f0de9f4cae8daeb025aff3904ecaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030701f081a9c6eab0c07b75433b524c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a030701f081a9c6eab0c07b75433b524c">decodeDaikin64</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a89266e9211a81eda22475fb5a258484f">kDaikin64Bits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a030701f081a9c6eab0c07b75433b524c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Daikin 64-bit message. (DAIKIN64) Status: Beta / Probably Working.  <a href="classIRrecv.html#a030701f081a9c6eab0c07b75433b524c">More...</a><br /></td></tr>
<tr class="separator:a030701f081a9c6eab0c07b75433b524c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7188577c874d9f8f19304a3ec775415"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#ac7188577c874d9f8f19304a3ec775415">decodeDaikin128</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a5bb2e6f8acbc0123de5ac0fd76e1646a">kDaikin128Bits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:ac7188577c874d9f8f19304a3ec775415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Daikin 128-bit message. (DAIKIN128) Status: STABLE / Known Working.  <a href="classIRrecv.html#ac7188577c874d9f8f19304a3ec775415">More...</a><br /></td></tr>
<tr class="separator:ac7188577c874d9f8f19304a3ec775415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20a6586b4e56cc428012ec96f5ccc2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#ab20a6586b4e56cc428012ec96f5ccc2c">decodeDaikin152</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#af056e1ac2d00c6d6440c3dd2ae283f09">kDaikin152Bits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:ab20a6586b4e56cc428012ec96f5ccc2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Daikin 152-bit message. (DAIKIN152) Status: STABLE / Known Working.  <a href="classIRrecv.html#ab20a6586b4e56cc428012ec96f5ccc2c">More...</a><br /></td></tr>
<tr class="separator:ab20a6586b4e56cc428012ec96f5ccc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b9822defe6b29099079d664d9dc413"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#af0b9822defe6b29099079d664d9dc413">decodeDaikin160</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#aa6f1d6dded2ae3500cd52aa0c482a1b6">kDaikin160Bits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:af0b9822defe6b29099079d664d9dc413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Daikin 160-bit message. (DAIKIN160) Status: STABLE / Confirmed working.  <a href="classIRrecv.html#af0b9822defe6b29099079d664d9dc413">More...</a><br /></td></tr>
<tr class="separator:af0b9822defe6b29099079d664d9dc413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa142d1340201b6fdc5b462f46fe21ee0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#aa142d1340201b6fdc5b462f46fe21ee0">decodeDaikin176</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a78baf9c97c548618428d2fcfd7cc91d7">kDaikin176Bits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:aa142d1340201b6fdc5b462f46fe21ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Daikin 176-bit message. (DAIKIN176) Status: STABLE / Expected to work.  <a href="classIRrecv.html#aa142d1340201b6fdc5b462f46fe21ee0">More...</a><br /></td></tr>
<tr class="separator:aa142d1340201b6fdc5b462f46fe21ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4799a0d45ea5562159c46939617d80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a4c4799a0d45ea5562159c46939617d80">decodeDaikin2</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#affd9b805fff390d05a83ff4eaa1c98de">kDaikin2Bits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a4c4799a0d45ea5562159c46939617d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Daikin 312-bit message. (DAIKIN2) Status: STABLE / Works as expected.  <a href="classIRrecv.html#a4c4799a0d45ea5562159c46939617d80">More...</a><br /></td></tr>
<tr class="separator:a4c4799a0d45ea5562159c46939617d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f860686a5c58aa8f4d1842cfb15b2f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a7f860686a5c58aa8f4d1842cfb15b2f9">decodeDaikin216</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a317bf475ee4c6ddd802995dc535377d9">kDaikin216Bits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a7f860686a5c58aa8f4d1842cfb15b2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Daikin 216-bit message. (DAIKIN216) Status: STABLE / Should be working.  <a href="classIRrecv.html#a7f860686a5c58aa8f4d1842cfb15b2f9">More...</a><br /></td></tr>
<tr class="separator:a7f860686a5c58aa8f4d1842cfb15b2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01228e51ede905beac689967bb14b538"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a01228e51ede905beac689967bb14b538">decodeToshibaAC</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbytes=<a class="el" href="IRremoteESP8266_8h.html#a172dde7867fa9a68902c3ad7ea9629b0">kToshibaACBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a01228e51ede905beac689967bb14b538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Toshiba A/C message. Status: STABLE / Working.  <a href="classIRrecv.html#a01228e51ede905beac689967bb14b538">More...</a><br /></td></tr>
<tr class="separator:a01228e51ede905beac689967bb14b538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2920c488173f3fa37f5325438157ced"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#ae2920c488173f3fa37f5325438157ced">decodeTrotec</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#ab819cb0a34937714dcb10059799c26e2">kTrotecBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:ae2920c488173f3fa37f5325438157ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Trotec message. Status: STABLE / Works. Untested on real devices.  <a href="classIRrecv.html#ae2920c488173f3fa37f5325438157ced">More...</a><br /></td></tr>
<tr class="separator:ae2920c488173f3fa37f5325438157ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255b15601f7439a09ab5e77ad78816fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a255b15601f7439a09ab5e77ad78816fb">decodeMidea</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#afc98096b1e2945e2eaeb07d70d511239">kMideaBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a255b15601f7439a09ab5e77ad78816fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Midea message. Status: Alpha / Needs testing against a real device.  <a href="classIRrecv.html#a255b15601f7439a09ab5e77ad78816fb">More...</a><br /></td></tr>
<tr class="separator:a255b15601f7439a09ab5e77ad78816fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a04019308b29ae2aea4b3a83ba9155"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a62a04019308b29ae2aea4b3a83ba9155">decodeMidea24</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#aff132faa67b1d07890378df5c9b52a14">kMidea24Bits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a62a04019308b29ae2aea4b3a83ba9155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Midea24 message. Status: STABLE / Confirmed working on a real device.  <a href="classIRrecv.html#a62a04019308b29ae2aea4b3a83ba9155">More...</a><br /></td></tr>
<tr class="separator:a62a04019308b29ae2aea4b3a83ba9155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3778bdf994bf9c99ac48ef95434a826"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#aa3778bdf994bf9c99ac48ef95434a826">decodeFujitsuAC</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#aecd63891cac014d1b7e344638086ad47">kFujitsuAcBits</a>, const bool strict=false)</td></tr>
<tr class="memdesc:aa3778bdf994bf9c99ac48ef95434a826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Fujitsu AC IR message if possible. Status: STABLE / Working.  <a href="classIRrecv.html#aa3778bdf994bf9c99ac48ef95434a826">More...</a><br /></td></tr>
<tr class="separator:aa3778bdf994bf9c99ac48ef95434a826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4af614a45ea65cb3304ef5bd7965122"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#ae4af614a45ea65cb3304ef5bd7965122">decodeLasertag</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a3ea0e89a8b6a3ffa4a2d346abeed851e">kLasertagBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:ae4af614a45ea65cb3304ef5bd7965122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Lasertag message. Status: BETA / Appears to be working 90% of the time.  <a href="classIRrecv.html#ae4af614a45ea65cb3304ef5bd7965122">More...</a><br /></td></tr>
<tr class="separator:ae4af614a45ea65cb3304ef5bd7965122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3d1c37038120a5c0996d92577ce74a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#acf3d1c37038120a5c0996d92577ce74a">decodeCarrierAC</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a668d9ac84f7dae61c35534b842d4956b">kCarrierAcBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:acf3d1c37038120a5c0996d92577ce74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Carrier HVAC message.  <a href="classIRrecv.html#acf3d1c37038120a5c0996d92577ce74a">More...</a><br /></td></tr>
<tr class="separator:acf3d1c37038120a5c0996d92577ce74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdb35ec34f49401a6b9becd15b8a3b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a4bdb35ec34f49401a6b9becd15b8a3b5">decodeCarrierAC40</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a56d1176a7b3fe59aeb3f4f39926c617d">kCarrierAc40Bits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a4bdb35ec34f49401a6b9becd15b8a3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Carrier 40-bit HVAC message. Carrier HVAC messages contain only 40 bits, but it is sent three(3) times. Status: STABLE / Tested against a real device.  <a href="classIRrecv.html#a4bdb35ec34f49401a6b9becd15b8a3b5">More...</a><br /></td></tr>
<tr class="separator:a4bdb35ec34f49401a6b9becd15b8a3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d03c31da48a385ab47cc8f342ef9b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a79d03c31da48a385ab47cc8f342ef9b3">decodeCarrierAC64</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a41bc7ab7289e499ad33901da3eab661a">kCarrierAc64Bits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a79d03c31da48a385ab47cc8f342ef9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Carrier 64-bit HVAC message. Status: STABLE / Known to be working.  <a href="classIRrecv.html#a79d03c31da48a385ab47cc8f342ef9b3">More...</a><br /></td></tr>
<tr class="separator:a79d03c31da48a385ab47cc8f342ef9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64650ce7dbaf5fc860a6a253d906e9de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a64650ce7dbaf5fc860a6a253d906e9de">decodeGoodweather</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#afa2675ce42d00175ec95caa6cd87a425">kGoodweatherBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a64650ce7dbaf5fc860a6a253d906e9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Goodweather message. Status: BETA / Probably works.  <a href="classIRrecv.html#a64650ce7dbaf5fc860a6a253d906e9de">More...</a><br /></td></tr>
<tr class="separator:a64650ce7dbaf5fc860a6a253d906e9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e756342d7524a13d53d6c656700638c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a2e756342d7524a13d53d6c656700638c">decodeGree</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#acadcc5d03e09784642f008d4d2913c7d">kGreeBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a2e756342d7524a13d53d6c656700638c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Gree HVAC message. Status: STABLE / Working.  <a href="classIRrecv.html#a2e756342d7524a13d53d6c656700638c">More...</a><br /></td></tr>
<tr class="separator:a2e756342d7524a13d53d6c656700638c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97403174f05197a7fa9a4a0107e3111"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#ad97403174f05197a7fa9a4a0107e3111">decodeHaierAC</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#ad44cfa0951c24d1f0c67b2fba997f720">kHaierACBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:ad97403174f05197a7fa9a4a0107e3111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Haier HSU07-HEA03 remote message. Status: STABLE / Known to be working.  <a href="classIRrecv.html#ad97403174f05197a7fa9a4a0107e3111">More...</a><br /></td></tr>
<tr class="separator:ad97403174f05197a7fa9a4a0107e3111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281fb9d972fee75db49209c42f649822"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a281fb9d972fee75db49209c42f649822">decodeHaierACYRW02</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#aab346c5ad482113978e5a2cbb7a06f27">kHaierACYRW02Bits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a281fb9d972fee75db49209c42f649822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Haier YR-W02 remote A/C message. Status: BETA / Appears to be working.  <a href="classIRrecv.html#a281fb9d972fee75db49209c42f649822">More...</a><br /></td></tr>
<tr class="separator:a281fb9d972fee75db49209c42f649822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42facfffc0e304005272b6ddd4583c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#aa42facfffc0e304005272b6ddd4583c8">decodeHitachiAC</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#aec91e459b1e52765c700f8f7a4723f3b">kHitachiAcBits</a>, const bool strict=true, const bool MSBfirst=true)</td></tr>
<tr class="memdesc:aa42facfffc0e304005272b6ddd4583c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Hitachi A/C message. Status: STABLE / Expected to work.  <a href="classIRrecv.html#aa42facfffc0e304005272b6ddd4583c8">More...</a><br /></td></tr>
<tr class="separator:aa42facfffc0e304005272b6ddd4583c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122e0dcbf14c90ec2d77399acce21459"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a122e0dcbf14c90ec2d77399acce21459">decodeHitachiAC1</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#aae6947c431d2c9da4fe2fdd9428012c1">kHitachiAc1Bits</a>, const bool strict=true)</td></tr>
<tr class="separator:a122e0dcbf14c90ec2d77399acce21459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113bc834eff00f55d5545ce3fa1ab203"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a113bc834eff00f55d5545ce3fa1ab203">decodeHitachiAc3</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#ac26b896cdc17018269fa881e10e3aabb">kHitachiAc3Bits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a113bc834eff00f55d5545ce3fa1ab203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Hitachi 15to27-byte/120to216-bit A/C message. Status: STABLE / Works fine.  <a href="classIRrecv.html#a113bc834eff00f55d5545ce3fa1ab203">More...</a><br /></td></tr>
<tr class="separator:a113bc834eff00f55d5545ce3fa1ab203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c3dda56d6d916076fa1affa2213129"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a01c3dda56d6d916076fa1affa2213129">decodeHitachiAc424</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#ab466e28528a0d688a1b91e8af69025cb">kHitachiAc424Bits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a01c3dda56d6d916076fa1affa2213129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Hitachi 53-byte/424-bit A/C message. Status: STABLE / Reported as working.  <a href="classIRrecv.html#a01c3dda56d6d916076fa1affa2213129">More...</a><br /></td></tr>
<tr class="separator:a01c3dda56d6d916076fa1affa2213129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afade8dac9b1d023e5e0946e6b2c08aea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#afade8dac9b1d023e5e0946e6b2c08aea">decodeGICable</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#aceb5cbd7ba5d8bc11560ba29137b10fa">kGicableBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:afade8dac9b1d023e5e0946e6b2c08aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied G.I. Cable message. Status: Alpha / Not tested against a real device.  <a href="classIRrecv.html#afade8dac9b1d023e5e0946e6b2c08aea">More...</a><br /></td></tr>
<tr class="separator:afade8dac9b1d023e5e0946e6b2c08aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1eec83cf092f5621cb34b3e94777c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a0d1eec83cf092f5621cb34b3e94777c4">decodeWhirlpoolAC</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a149bd4f3fb9c83e683095d393209ede3">kWhirlpoolAcBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a0d1eec83cf092f5621cb34b3e94777c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Whirlpool A/C message. Status: STABLE / Working as intended.  <a href="classIRrecv.html#a0d1eec83cf092f5621cb34b3e94777c4">More...</a><br /></td></tr>
<tr class="separator:a0d1eec83cf092f5621cb34b3e94777c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6093c4404a9a9d415c5bfeab5ec53be5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a6093c4404a9a9d415c5bfeab5ec53be5">decodeLutron</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a814dfab515b91887c494237b1f6ebd99">kLutronBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a6093c4404a9a9d415c5bfeab5ec53be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Lutron message. Status: STABLE / Working.  <a href="classIRrecv.html#a6093c4404a9a9d415c5bfeab5ec53be5">More...</a><br /></td></tr>
<tr class="separator:a6093c4404a9a9d415c5bfeab5ec53be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a7be8afc36451c8e28e27f3c3e9aaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#ad3a7be8afc36451c8e28e27f3c3e9aaa">decodeElectraAC</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#aa46876681f26ccf39c6d341fef041a16">kElectraAcBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:ad3a7be8afc36451c8e28e27f3c3e9aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Electra A/C message. Status: STABLE / Known working.  <a href="classIRrecv.html#ad3a7be8afc36451c8e28e27f3c3e9aaa">More...</a><br /></td></tr>
<tr class="separator:ad3a7be8afc36451c8e28e27f3c3e9aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f78e180ed731e8fb16d1c85aa721c95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a0f78e180ed731e8fb16d1c85aa721c95">decodePanasonicAC</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a210f5c78b0f90b64dd5037698141433a">kPanasonicAcBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a0f78e180ed731e8fb16d1c85aa721c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Panasonic AC message. Status: STABLE / Works with real device(s).  <a href="classIRrecv.html#a0f78e180ed731e8fb16d1c85aa721c95">More...</a><br /></td></tr>
<tr class="separator:a0f78e180ed731e8fb16d1c85aa721c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a9487cbe8a562392a07a4090b3091e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a78a9487cbe8a562392a07a4090b3091e">decodePioneer</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a6a7ccd31e0a6f967a219b1a53b89653b">kPioneerBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a78a9487cbe8a562392a07a4090b3091e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Pioneer message. Status: STABLE / Should be working. (Self decodes &amp; real examples)  <a href="classIRrecv.html#a78a9487cbe8a562392a07a4090b3091e">More...</a><br /></td></tr>
<tr class="separator:a78a9487cbe8a562392a07a4090b3091e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27518b5d792cdf3ab333b324f409f328"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a27518b5d792cdf3ab333b324f409f328">decodeMWM</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=24, const bool strict=true)</td></tr>
<tr class="memdesc:a27518b5d792cdf3ab333b324f409f328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied MWM message. Status: Implemented.  <a href="classIRrecv.html#a27518b5d792cdf3ab333b324f409f328">More...</a><br /></td></tr>
<tr class="separator:a27518b5d792cdf3ab333b324f409f328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d48b3c91434c18c7726cca504d75b73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a5d48b3c91434c18c7726cca504d75b73">decodeVestelAc</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#ae31945a1ce90b2d4c33b5c91d980d3a7">kVestelAcBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a5d48b3c91434c18c7726cca504d75b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Vestel message. Status: Alpha / Needs testing against a real device.  <a href="classIRrecv.html#a5d48b3c91434c18c7726cca504d75b73">More...</a><br /></td></tr>
<tr class="separator:a5d48b3c91434c18c7726cca504d75b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950711d7df8dfe4cda86f53650cd9f56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a950711d7df8dfe4cda86f53650cd9f56">decodeTeco</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#aee01958e9d97a70a6881cf560ca0ca9d">kTecoBits</a>, const bool strict=false)</td></tr>
<tr class="memdesc:a950711d7df8dfe4cda86f53650cd9f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Teco message. Status: STABLE / Tested.  <a href="classIRrecv.html#a950711d7df8dfe4cda86f53650cd9f56">More...</a><br /></td></tr>
<tr class="separator:a950711d7df8dfe4cda86f53650cd9f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea75ad0ba1d8fec33de16501940f2553"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#aea75ad0ba1d8fec33de16501940f2553">decodeLegoPf</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a8a7c7659250a81c7c84fc739eafed13e">kLegoPfBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:aea75ad0ba1d8fec33de16501940f2553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied LEGO Power Functions message. Status: STABLE / Appears to work.  <a href="classIRrecv.html#aea75ad0ba1d8fec33de16501940f2553">More...</a><br /></td></tr>
<tr class="separator:aea75ad0ba1d8fec33de16501940f2553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4729ee949e533448b481ae33bbbf1adf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a4729ee949e533448b481ae33bbbf1adf">decodeNeoclima</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#afff9132e57296b4d7e04ec9e1e5ab04f">kNeoclimaBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a4729ee949e533448b481ae33bbbf1adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Neoclima message. Status: STABLE / Known working.  <a href="classIRrecv.html#a4729ee949e533448b481ae33bbbf1adf">More...</a><br /></td></tr>
<tr class="separator:a4729ee949e533448b481ae33bbbf1adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d81fcfb47e36925975d313027689a44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a8d81fcfb47e36925975d313027689a44">decodeAmcor</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a34bcab75a8ab94adfd46a245dd0748db">kAmcorBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a8d81fcfb47e36925975d313027689a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Amcor HVAC message. Status: STABLE / Reported as working.  <a href="classIRrecv.html#a8d81fcfb47e36925975d313027689a44">More...</a><br /></td></tr>
<tr class="separator:a8d81fcfb47e36925975d313027689a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadef8415f273ba25f4086fecd681d2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#aaadef8415f273ba25f4086fecd681d2e">decodeEpson</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a77a0ed1143f5bfec87e0c9fde5c2c425">kEpsonBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:aaadef8415f273ba25f4086fecd681d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Epson message. Status: Beta / Probably works.  <a href="classIRrecv.html#aaadef8415f273ba25f4086fecd681d2e">More...</a><br /></td></tr>
<tr class="separator:aaadef8415f273ba25f4086fecd681d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cdf4d891654521afbc6ca9fb415745"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a61cdf4d891654521afbc6ca9fb415745">decodeSymphony</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#abb5b89578ab0757999530c0383f38533">kSymphonyBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a61cdf4d891654521afbc6ca9fb415745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Symphony packet/message. Status: STABLE / Should be working.  <a href="classIRrecv.html#a61cdf4d891654521afbc6ca9fb415745">More...</a><br /></td></tr>
<tr class="separator:a61cdf4d891654521afbc6ca9fb415745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4635d5ee146a82498cb0c269b6af41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#acf4635d5ee146a82498cb0c269b6af41">decodeAirwell</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a570219a14f2d19c7a6ce0aecd37a3b1f">kAirwellBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:acf4635d5ee146a82498cb0c269b6af41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Airwell "Manchester code" message.  <a href="classIRrecv.html#acf4635d5ee146a82498cb0c269b6af41">More...</a><br /></td></tr>
<tr class="separator:acf4635d5ee146a82498cb0c269b6af41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c91cc83770d243e942387cc16e9ca6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a8c91cc83770d243e942387cc16e9ca6f">decodeDelonghiAc</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a7b9fba82b602cf38147f0586e037f909">kDelonghiAcBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a8c91cc83770d243e942387cc16e9ca6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Delonghi A/C message. Status: STABLE / Expected to be working.  <a href="classIRrecv.html#a8c91cc83770d243e942387cc16e9ca6f">More...</a><br /></td></tr>
<tr class="separator:a8c91cc83770d243e942387cc16e9ca6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675c45e6b32aaeca3de734ccf2f0c819"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a675c45e6b32aaeca3de734ccf2f0c819">decodeDoshisha</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#aedc53534cf6a40144be80abeee498362">kDoshishaBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a675c45e6b32aaeca3de734ccf2f0c819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Doshisha message. Status: STABLE / Works on real device.  <a href="classIRrecv.html#a675c45e6b32aaeca3de734ccf2f0c819">More...</a><br /></td></tr>
<tr class="separator:a675c45e6b32aaeca3de734ccf2f0c819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61afacc9865232643164ba824e665ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#af61afacc9865232643164ba824e665ab">decodeMultibrackets</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#aad7be0971479839493615cafcd654fc1">kMultibracketsBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:af61afacc9865232643164ba824e665ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the Multibrackets message. Status: BETA / Appears to be working.  <a href="classIRrecv.html#af61afacc9865232643164ba824e665ab">More...</a><br /></td></tr>
<tr class="separator:af61afacc9865232643164ba824e665ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981cba14551c93af57f9c1c0e1775d12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a981cba14551c93af57f9c1c0e1775d12">decodeCoronaAc</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#a1191a9293b03aa14426083b6f411a4e3">kCoronaAcBitsShort</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a981cba14551c93af57f9c1c0e1775d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied CoronaAc message. Status: STABLE / Appears to be working.  <a href="classIRrecv.html#a981cba14551c93af57f9c1c0e1775d12">More...</a><br /></td></tr>
<tr class="separator:a981cba14551c93af57f9c1c0e1775d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72afd857c8b2e0192021a40afc96c2d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a72afd857c8b2e0192021a40afc96c2d8">decodeZepeal</a> (<a class="el" href="classdecode__results.html">decode_results</a> *results, uint16_t offset=<a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a>, const uint16_t nbits=<a class="el" href="IRremoteESP8266_8h.html#af09c9402a1c4fa24f692994498641296">kZepealBits</a>, const bool strict=true)</td></tr>
<tr class="memdesc:a72afd857c8b2e0192021a40afc96c2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the supplied Zepeal message. Status: STABLE / Works on real device.  <a href="classIRrecv.html#a72afd857c8b2e0192021a40afc96c2d8">More...</a><br /></td></tr>
<tr class="separator:a72afd857c8b2e0192021a40afc96c2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a6fdac84ce51ce119972bf121ccc95aab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structirparams__t.html">irparams_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a6fdac84ce51ce119972bf121ccc95aab">irparams_save</a></td></tr>
<tr class="separator:a6fdac84ce51ce119972bf121ccc95aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0459a65dd31b215713ad66a1e4f3540e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#a0459a65dd31b215713ad66a1e4f3540e">_tolerance</a></td></tr>
<tr class="separator:a0459a65dd31b215713ad66a1e4f3540e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff11c0c20735b16ce411088003607911"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#aff11c0c20735b16ce411088003607911">_timer_num</a></td></tr>
<tr class="separator:aff11c0c20735b16ce411088003607911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8cbc5c1cb739f33f5be25b3a6c79bd"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIRrecv.html#adb8cbc5c1cb739f33f5be25b3a6c79bd">_unknown_threshold</a></td></tr>
<tr class="separator:adb8cbc5c1cb739f33f5be25b3a6c79bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for receiving IR messages. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8fe4d26ef1f863db1db9994fed5fc209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe4d26ef1f863db1db9994fed5fc209">&#9670;&nbsp;</a></span>IRrecv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IRrecv::IRrecv </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>recvpin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>bufsize</em> = <code><a class="el" href="IRrecv_8h.html#aadfa37def10a1adeaf2cf4c09d7504e3">kRawBuf</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="IRrecv_8h.html#ad37e9659aaef29c541802d9759e0ab7b">kTimeoutMs</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>save_buffer</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>timer_num</em> = <code><a class="el" href="IRrecv_8h.html#a80a2d3445a1752d18caf307d7677b709">kDefaultESP32Timer</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class constructor Args: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recvpin</td><td>The GPIO pin the IR receiver module's data pin is connected to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufsize</td><td>Nr. of entries to have in the capture buffer. (Default: kRawBuf) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Nr. of milli-Seconds of no signal before we stop capturing data. (Default: kTimeoutMs) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">save_buffer</td><td>Use a second (save) buffer to decode from. (Default: false) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timer_num</td><td>Nr. of the ESP32 timer to use (0 to 3) (ESP32 Only) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bb1bcc1c1a3184294dd35c8f6f758b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb1bcc1c1a3184294dd35c8f6f758b1">&#9670;&nbsp;</a></span>IRrecv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IRrecv::IRrecv </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>recvpin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>bufsize</em> = <code><a class="el" href="IRrecv_8h.html#aadfa37def10a1adeaf2cf4c09d7504e3">kRawBuf</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="IRrecv_8h.html#ad37e9659aaef29c541802d9759e0ab7b">kTimeoutMs</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>save_buffer</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87d4cca5e350177cb0922842dda1eb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d4cca5e350177cb0922842dda1eb5b">&#9670;&nbsp;</a></span>~IRrecv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IRrecv::~IRrecv </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class destructor Cleans up after the object is no longer needed. e.g. Frees up all memory used by the various buffers, and disables any timers or interrupts used. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af0b300fe6fdff58324525e8208be3024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b300fe6fdff58324525e8208be3024">&#9670;&nbsp;</a></span>_matchGeneric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t IRrecv::_matchGeneric </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result_bits_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>result_bytes_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>remaining</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>hdrmark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>hdrspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>onemark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>onespace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>zeromark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>zerospace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>footermark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>footerspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>atleast</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>excess</em> = <code><a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>MSBfirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match &amp; decode a generic/typical IR message. The data is stored in result_bits_ptr or result_bytes_ptr depending on flag <code>use_bits</code>. </p>
<dl class="section note"><dt>Note</dt><dd>Values of 0 for hdrmark, hdrspace, footermark, or footerspace mean skip that requirement.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_ptr</td><td>A pointer to where we are at in the capture buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_bits_ptr</td><td>A pointer to where to start storing the bits we decoded. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_bytes_ptr</td><td>A pointer to where to start storing the bytes we decoded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_bits</td><td>A flag indicating if we are to decode bits or bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remaining</td><td>The size of the capture buffer remaining. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>Nr. of data bits we expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hdrmark</td><td>Nr. of uSeconds for the expected header mark signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hdrspace</td><td>Nr. of uSeconds for the expected header space signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onemark</td><td>Nr. of uSeconds in an expected mark signal for a '1' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onespace</td><td>Nr. of uSecs in an expected space signal for a '1' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zeromark</td><td>Nr. of uSecs in an expected mark signal for a '0' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zerospace</td><td>Nr. of uSecs in an expected space signal for a '0' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">footermark</td><td>Nr. of uSeconds for the expected footer mark signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">footerspace</td><td>Nr. of uSeconds for the expected footer space/gap signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">atleast</td><td>Is the match on the footerspace a matchAtLeast or matchSpace? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>Percentage error margin to allow. (Default: kUseDefTol) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">excess</td><td>Nr. of uSeconds. (Def: kMarkExcess) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MSBfirst</td><td>Bit order to save the data in. (Def: true) true is Most Significant Bit First Order, false is Least Significant First </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, how many buffer entries were used. Otherwise 0. </dd></dl>

</div>
</div>
<a id="a0b4221970de0d027b5ae99648fa1c003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4221970de0d027b5ae99648fa1c003">&#9670;&nbsp;</a></span>_validTolerance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t IRrecv::_validTolerance </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>percentage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the tolerance percentage into something valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">percentage</td><td>An integer percentage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7347c72b14d9f2f20f65bcf235ab3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7347c72b14d9f2f20f65bcf235ab3dc">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t IRrecv::compare </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>oldval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>newval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two tick values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oldval</td><td>Nr. of ticks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newval</td><td>Nr. of ticks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if newval is shorter, 1 if it is equal, &amp; 2 if it is longer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use a tolerance of 20% </dd></dl>

</div>
</div>
<a id="ab017a0f9256954bb7d943e3c6b7e31bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab017a0f9256954bb7d943e3c6b7e31bf">&#9670;&nbsp;</a></span>copyIrParams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::copyIrParams </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="structirparams__t.html">irparams_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structirparams__t.html">irparams_t</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a copy of the interrupt state &amp; buffer data. Needed because irparams is marked as volatile, thus memcpy() isn't allowed. Only call this when you know the interrupt handlers won't modify anything. i.e. In kStopState. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Pointer to an <a class="el" href="structirparams__t.html" title="Information for the interrupt handler.">irparams_t</a> structure to copy from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>Pointer to an <a class="el" href="structirparams__t.html" title="Information for the interrupt handler.">irparams_t</a> structure to copy to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae833bdb8fccc676043fc4ccae432fab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae833bdb8fccc676043fc4ccae432fab1">&#9670;&nbsp;</a></span>crudeNoiseFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::crudeNoiseFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>floor</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove or merge pulses in the capture buffer that are too short. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the <a class="el" href="classdecode__results.html" title="Results returned from the decoder.">decode_results</a> we are going to filter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">floor</td><td>Only allow values in the buffer large than this. (in microSeconds) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeaa5c07a8b46f8fbb982f996cc1f9f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa5c07a8b46f8fbb982f996cc1f9f4b">&#9670;&nbsp;</a></span>decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structirparams__t.html">irparams_t</a> *&#160;</td>
          <td class="paramname"><em>save</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>max_skip</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>noise_floor</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the received IR message. If the interrupt state is saved, we will immediately resume waiting for the next IR message to avoid missing messages. </p>
<dl class="section note"><dt>Note</dt><dd>There is a trade-off here. Saving the state means less time lost until we can receiving the next message vs. using more RAM. Choose appropriately. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>A PTR to where the decoded IR message will be stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">save</td><td>A PTR to an <a class="el" href="structirparams__t.html" title="Information for the interrupt handler.">irparams_t</a> instance in which to save the interrupt's memory/state. NULL means don't save it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_skip</td><td>Maximum Nr. of pulses at the begining of a capture we can skip when attempting to find a protocol we can successfully decode. This parameter can dramatically improve detection of protocols when there is light IR interference just before an incoming IR message, however, it comes at a steep performace price. (Default is 0. No skipping.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Increasing the <code>max_skip</code> value will dramatically (linearly) increase the cpu time &amp; usage to decode protocols. e.g. 0 -&gt; 1 will be a 2x increase in cpu usage/time. 0 -&gt; 2 will be a 3x increase etc. If you are going to do this, consider disabling protocol decoding for protocols you are not expecting. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">noise_floor</td><td>Pulses below this size (in usecs) will be removed or merged prior to any decoding. This is to try to remove noise/poor readings &amp; slighly increase the chances of a successful decode but at the cost of data fidelity &amp; integrity. (Defaults to 0 usecs. i.e. Don't filter; which is safe!) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>DANGER: <b>Here Be Dragons!</b> If you set the <code>noise_floor</code> value too high, it <b>WILL</b> break decoding of some protocols. You have been warned! <b>Any</b> non-zero value has the potential to <b>cook</b> the captured raw data i.e. The raw data is going to lie to you. It may obscure hardware, circuit, &amp; environment issues thus making it impossible to support you accurately or confidently. Values of &lt;= 50 usecs will probably be safe. 51 - 100 usecs <b>might</b> be okay. 100 - 150 usecs is "Danger, Will Robinson!". 150 - 200 usecs expect broken protocols. At 200+ usecs, you <b>have</b> protocols you can't decode!! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean indicating if an IR message is ready or not. </dd></dl>

</div>
</div>
<a id="acf4635d5ee146a82498cb0c269b6af41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4635d5ee146a82498cb0c269b6af41">&#9670;&nbsp;</a></span>decodeAirwell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeAirwell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a570219a14f2d19c7a6ce0aecd37a3b1f">kAirwellBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Airwell "Manchester code" message. </p>
<p>Status: BETA / Appears to be working. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/1069">https://github.com/crankyoldgit/IRremoteESP8266/issues/1069</a> </dd></dl>

</div>
</div>
<a id="aa4d678376a4c0f8ea953474a6f5ef9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d678376a4c0f8ea953474a6f5ef9d2">&#9670;&nbsp;</a></span>decodeAiwaRCT501()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeAiwaRCT501 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a9078adf040d21c9c3eb10ed69f9dced6">kAiwaRcT501Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Aiwa RC T501 message. Status: BETA / Should work. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Aiwa RC T501 appears to be a 42 bit variant of the NEC1 protocol. However, we historically (original Arduino IRremote project) treats it as a 15 bit (data) protocol. So, we expect nbits to typically be 15, and we will remove the prefix and postfix from the raw data, and use that as the result. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.sbprojects.com/knowledge/ir/nec.php">http://www.sbprojects.com/knowledge/ir/nec.php</a> </dd>
<dd>
<a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/1069">https://github.com/crankyoldgit/IRremoteESP8266/issues/1069</a> </dd></dl>

</div>
</div>
<a id="a8d81fcfb47e36925975d313027689a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d81fcfb47e36925975d313027689a44">&#9670;&nbsp;</a></span>decodeAmcor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeAmcor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a34bcab75a8ab94adfd46a245dd0748db">kAmcorBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Amcor HVAC message. Status: STABLE / Reported as working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a94f12dc000a6e7b75ea8680fd48fc487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f12dc000a6e7b75ea8680fd48fc487">&#9670;&nbsp;</a></span>decodeArgo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeArgo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a351efcd1805c87bd338de81dab3f8fb2">kArgoBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Argo message. Status: BETA / Probably works. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This decoder is based soley off sendArgo(). We have no actual captures to test this against. If you have one of these units, please let us know. </dd></dl>

</div>
</div>
<a id="acf3d1c37038120a5c0996d92577ce74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3d1c37038120a5c0996d92577ce74a">&#9670;&nbsp;</a></span>decodeCarrierAC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeCarrierAC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a668d9ac84f7dae61c35534b842d4956b">kCarrierAcBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Carrier HVAC message. </p>
<dl class="section note"><dt>Note</dt><dd>Carrier HVAC messages contain only 32 bits, but it is sent three(3) times. i.e. normal + inverted + normal Status: BETA / Probably works. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a4bdb35ec34f49401a6b9becd15b8a3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bdb35ec34f49401a6b9becd15b8a3b5">&#9670;&nbsp;</a></span>decodeCarrierAC40()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeCarrierAC40 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a56d1176a7b3fe59aeb3f4f39926c617d">kCarrierAc40Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Carrier 40-bit HVAC message. Carrier HVAC messages contain only 40 bits, but it is sent three(3) times. Status: STABLE / Tested against a real device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a79d03c31da48a385ab47cc8f342ef9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d03c31da48a385ab47cc8f342ef9b3">&#9670;&nbsp;</a></span>decodeCarrierAC64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeCarrierAC64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a41bc7ab7289e499ad33901da3eab661a">kCarrierAc64Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Carrier 64-bit HVAC message. Status: STABLE / Known to be working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a964af7e72e2133688f0596c718cb98ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964af7e72e2133688f0596c718cb98ca">&#9670;&nbsp;</a></span>decodeCOOLIX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeCOOLIX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#aed48c68a637e4b45b80bbf4964ea79f9">kCoolixBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Coolix A/C message. Status: STABLE / Known Working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a981cba14551c93af57f9c1c0e1775d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981cba14551c93af57f9c1c0e1775d12">&#9670;&nbsp;</a></span>decodeCoronaAc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeCoronaAc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a1191a9293b03aa14426083b6f411a4e3">kCoronaAcBitsShort</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied CoronaAc message. Status: STABLE / Appears to be working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store it </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a141f0de9f4cae8daeb025aff3904ecaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141f0de9f4cae8daeb025aff3904ecaa">&#9670;&nbsp;</a></span>decodeDaikin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeDaikin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a657f8e60bc1f896d4a46ec101c289485">kDaikinBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Daikin 280-bit message. (DAIKIN) Status: STABLE / Reported as working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/mharizanov/Daikin-AC-remote-control-over-the-Internet/tree/master/IRremote">https://github.com/mharizanov/Daikin-AC-remote-control-over-the-Internet/tree/master/IRremote</a> </dd></dl>

</div>
</div>
<a id="ac7188577c874d9f8f19304a3ec775415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7188577c874d9f8f19304a3ec775415">&#9670;&nbsp;</a></span>decodeDaikin128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeDaikin128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a5bb2e6f8acbc0123de5ac0fd76e1646a">kDaikin128Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Daikin 128-bit message. (DAIKIN128) Status: STABLE / Known Working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/827">https://github.com/crankyoldgit/IRremoteESP8266/issues/827</a> </dd></dl>

</div>
</div>
<a id="ab20a6586b4e56cc428012ec96f5ccc2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20a6586b4e56cc428012ec96f5ccc2c">&#9670;&nbsp;</a></span>decodeDaikin152()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeDaikin152 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#af056e1ac2d00c6d6440c3dd2ae283f09">kDaikin152Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Daikin 152-bit message. (DAIKIN152) Status: STABLE / Known Working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/873">https://github.com/crankyoldgit/IRremoteESP8266/issues/873</a> </dd></dl>

</div>
</div>
<a id="af0b9822defe6b29099079d664d9dc413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b9822defe6b29099079d664d9dc413">&#9670;&nbsp;</a></span>decodeDaikin160()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeDaikin160 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#aa6f1d6dded2ae3500cd52aa0c482a1b6">kDaikin160Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Daikin 160-bit message. (DAIKIN160) Status: STABLE / Confirmed working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/731">https://github.com/crankyoldgit/IRremoteESP8266/issues/731</a> </dd></dl>

</div>
</div>
<a id="aa142d1340201b6fdc5b462f46fe21ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa142d1340201b6fdc5b462f46fe21ee0">&#9670;&nbsp;</a></span>decodeDaikin176()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeDaikin176 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a78baf9c97c548618428d2fcfd7cc91d7">kDaikin176Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Daikin 176-bit message. (DAIKIN176) Status: STABLE / Expected to work. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a4c4799a0d45ea5562159c46939617d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4799a0d45ea5562159c46939617d80">&#9670;&nbsp;</a></span>decodeDaikin2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeDaikin2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#affd9b805fff390d05a83ff4eaa1c98de">kDaikin2Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Daikin 312-bit message. (DAIKIN2) Status: STABLE / Works as expected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a7f860686a5c58aa8f4d1842cfb15b2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f860686a5c58aa8f4d1842cfb15b2f9">&#9670;&nbsp;</a></span>decodeDaikin216()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeDaikin216 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a317bf475ee4c6ddd802995dc535377d9">kDaikin216Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Daikin 216-bit message. (DAIKIN216) Status: STABLE / Should be working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/689">https://github.com/crankyoldgit/IRremoteESP8266/issues/689</a> </dd>
<dd>
<a href="https://github.com/danny-source/Arduino_DY_IRDaikin">https://github.com/danny-source/Arduino_DY_IRDaikin</a> </dd></dl>

</div>
</div>
<a id="a030701f081a9c6eab0c07b75433b524c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030701f081a9c6eab0c07b75433b524c">&#9670;&nbsp;</a></span>decodeDaikin64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeDaikin64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a89266e9211a81eda22475fb5a258484f">kDaikin64Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Daikin 64-bit message. (DAIKIN64) Status: Beta / Probably Working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/1064">https://github.com/crankyoldgit/IRremoteESP8266/issues/1064</a> </dd></dl>

</div>
</div>
<a id="a8c91cc83770d243e942387cc16e9ca6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c91cc83770d243e942387cc16e9ca6f">&#9670;&nbsp;</a></span>decodeDelonghiAc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeDelonghiAc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a7b9fba82b602cf38147f0586e037f909">kDelonghiAcBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Delonghi A/C message. Status: STABLE / Expected to be working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/1096">https://github.com/crankyoldgit/IRremoteESP8266/issues/1096</a> </dd></dl>

</div>
</div>
<a id="a0b1bd1c817cb43bc3755126191b7f4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1bd1c817cb43bc3755126191b7f4a2">&#9670;&nbsp;</a></span>decodeDenon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeDenon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a29160117e25f3dfc1cb899a4a53bc238">kDenonBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Delonghi A/C message. Status: STABLE / Should work fine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/z3t0/Arduino-IRremote/blob/master/ir_Denon.cpp">https://github.com/z3t0/Arduino-IRremote/blob/master/ir_Denon.cpp</a> </dd></dl>

</div>
</div>
<a id="a851776d9178aeb706d9a1abd3f254e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851776d9178aeb706d9a1abd3f254e31">&#9670;&nbsp;</a></span>decodeDISH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeDISH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#aea0cc15e1c7a6edcd6b60d9ac62d4831">kDishBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied DISH NETWORK message. Status: ALPHA (untested and unconfirmed.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Dishplayer is a different protocol. Typically a DISH device needs to get a command a total of at least 4 times to accept it. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.hifi-remote.com/wiki/index.php?title=Dish">http://www.hifi-remote.com/wiki/index.php?title=Dish</a> </dd>
<dd>
<a href="http://lirc.sourceforge.net/remotes/echostar/301_501_3100_5100_58xx_59xx">http://lirc.sourceforge.net/remotes/echostar/301_501_3100_5100_58xx_59xx</a> </dd>
<dd>
<a href="https://github.com/marcosamarinho/IRremoteESP8266/blob/master/ir_Dish.cpp">https://github.com/marcosamarinho/IRremoteESP8266/blob/master/ir_Dish.cpp</a> </dd></dl>

</div>
</div>
<a id="a675c45e6b32aaeca3de734ccf2f0c819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675c45e6b32aaeca3de734ccf2f0c819">&#9670;&nbsp;</a></span>decodeDoshisha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeDoshisha </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#aedc53534cf6a40144be80abeee498362">kDoshishaBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Doshisha message. Status: STABLE / Works on real device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="ad3a7be8afc36451c8e28e27f3c3e9aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a7be8afc36451c8e28e27f3c3e9aaa">&#9670;&nbsp;</a></span>decodeElectraAC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeElectraAC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#aa46876681f26ccf39c6d341fef041a16">kElectraAcBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Electra A/C message. Status: STABLE / Known working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="aaadef8415f273ba25f4086fecd681d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaadef8415f273ba25f4086fecd681d2e">&#9670;&nbsp;</a></span>decodeEpson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeEpson </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a77a0ed1143f5bfec87e0c9fde5c2c425">kEpsonBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Epson message. Status: Beta / Probably works. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Experimental data indicates there are at least three messages (first + 2 repeats). We only require the first + a single repeat to match. This helps us distinguish it from NEC messages which are near identical. </dd></dl>

</div>
</div>
<a id="aa3778bdf994bf9c99ac48ef95434a826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3778bdf994bf9c99ac48ef95434a826">&#9670;&nbsp;</a></span>decodeFujitsuAC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeFujitsuAC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#aecd63891cac014d1b7e344638086ad47">kFujitsuAcBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Fujitsu AC IR message if possible. Status: STABLE / Working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="afade8dac9b1d023e5e0946e6b2c08aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afade8dac9b1d023e5e0946e6b2c08aea">&#9670;&nbsp;</a></span>decodeGICable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeGICable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#aceb5cbd7ba5d8bc11560ba29137b10fa">kGicableBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied G.I. Cable message. Status: Alpha / Not tested against a real device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a64650ce7dbaf5fc860a6a253d906e9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64650ce7dbaf5fc860a6a253d906e9de">&#9670;&nbsp;</a></span>decodeGoodweather()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeGoodweather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#afa2675ce42d00175ec95caa6cd87a425">kGoodweatherBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Goodweather message. Status: BETA / Probably works. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a2e756342d7524a13d53d6c656700638c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e756342d7524a13d53d6c656700638c">&#9670;&nbsp;</a></span>decodeGree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeGree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#acadcc5d03e09784642f008d4d2913c7d">kGreeBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Gree HVAC message. Status: STABLE / Working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="ad97403174f05197a7fa9a4a0107e3111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97403174f05197a7fa9a4a0107e3111">&#9670;&nbsp;</a></span>decodeHaierAC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeHaierAC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#ad44cfa0951c24d1f0c67b2fba997f720">kHaierACBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Haier HSU07-HEA03 remote message. Status: STABLE / Known to be working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a281fb9d972fee75db49209c42f649822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281fb9d972fee75db49209c42f649822">&#9670;&nbsp;</a></span>decodeHaierACYRW02()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeHaierACYRW02 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#aab346c5ad482113978e5a2cbb7a06f27">kHaierACYRW02Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Haier YR-W02 remote A/C message. Status: BETA / Appears to be working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a7c15fbfa7936ca474712a1953911fd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c15fbfa7936ca474712a1953911fd06">&#9670;&nbsp;</a></span>decodeHash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeHash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode any arbitrary IR message into a 32-bit code value. Instead of decoding using a standard encoding scheme (e.g. Sony, NEC, RC5), the code is hashed to a 32-bit value. </p>
<p>The algorithm: look at the sequence of MARK signals, and see if each one is shorter (0), the same length (1), or longer (2) than the previous. Do the same with the SPACE signals. Hash the resulting sequence of 0's, 1's, and 2's to a 32-bit value. This will give a unique value for each different code (probably), for most code systems. </p><dl class="section see"><dt>See also</dt><dd><a href="http://arcfn.com/2010/01/using-arbitrary-remotes-with-arduino.html">http://arcfn.com/2010/01/using-arbitrary-remotes-with-arduino.html</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This isn't a "real" decoding, just an arbitrary value. Hopefully this code is unique for each button. </dd></dl>

</div>
</div>
<a id="aa42facfffc0e304005272b6ddd4583c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42facfffc0e304005272b6ddd4583c8">&#9670;&nbsp;</a></span>decodeHitachiAC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeHitachiAC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#aec91e459b1e52765c700f8f7a4723f3b">kHitachiAcBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>MSBfirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Hitachi A/C message. Status: STABLE / Expected to work. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. Typically kHitachiAcBits, kHitachiAc1Bits, kHitachiAc2Bits, kHitachiAc344Bits </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MSBfirst</td><td>Is the data per byte stored in MSB First (true) or LSB First order(false)? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/417">https://github.com/crankyoldgit/IRremoteESP8266/issues/417</a> </dd>
<dd>
<a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/453">https://github.com/crankyoldgit/IRremoteESP8266/issues/453</a> </dd>
<dd>
<a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/1134">https://github.com/crankyoldgit/IRremoteESP8266/issues/1134</a> </dd></dl>

</div>
</div>
<a id="a122e0dcbf14c90ec2d77399acce21459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122e0dcbf14c90ec2d77399acce21459">&#9670;&nbsp;</a></span>decodeHitachiAC1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeHitachiAC1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#aae6947c431d2c9da4fe2fdd9428012c1">kHitachiAc1Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a113bc834eff00f55d5545ce3fa1ab203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113bc834eff00f55d5545ce3fa1ab203">&#9670;&nbsp;</a></span>decodeHitachiAc3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeHitachiAc3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#ac26b896cdc17018269fa881e10e3aabb">kHitachiAc3Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Hitachi 15to27-byte/120to216-bit A/C message. Status: STABLE / Works fine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This protocol is almost exactly the same as HitachiAC424 except this variant has subtle timing differences and multiple lengths. There are five(5) typical lengths: kHitachiAc3MinStateLength (Cancel Timer), kHitachiAc3MinStateLength + 2 (Change Temp), kHitachiAc3StateLength - 6 (Change Mode), kHitachiAc3StateLength - 4 (Normal), &amp; kHitachiAc3StateLength (Set Timer) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/1060">https://github.com/crankyoldgit/IRremoteESP8266/issues/1060</a> </dd></dl>

</div>
</div>
<a id="a01c3dda56d6d916076fa1affa2213129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c3dda56d6d916076fa1affa2213129">&#9670;&nbsp;</a></span>decodeHitachiAc424()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeHitachiAc424 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#ab466e28528a0d688a1b91e8af69025cb">kHitachiAc424Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Hitachi 53-byte/424-bit A/C message. Status: STABLE / Reported as working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This protocol is almost exactly the same as HitachiAC2 except this variant has a leader section as well, and subtle timing differences. It is also in LSBF order (per byte), rather than MSBF order. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/973">https://github.com/crankyoldgit/IRremoteESP8266/issues/973</a> </dd>
<dd>
(Japanese Manual) <a href="https://kadenfan.hitachi.co.jp/support/raj/item/docs/ras_aj22h_a_tori.pdf">https://kadenfan.hitachi.co.jp/support/raj/item/docs/ras_aj22h_a_tori.pdf</a> </dd></dl>

</div>
</div>
<a id="a94545c6a8da027b9cb0e23ecba4c29d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94545c6a8da027b9cb0e23ecba4c29d8">&#9670;&nbsp;</a></span>decodeInax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeInax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#af8441f25b32d113096adeaff331c126a">kInaxBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Inax Toilet message. Status: Stable / Known working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/706">https://github.com/crankyoldgit/IRremoteESP8266/issues/706</a> </dd></dl>

</div>
</div>
<a id="a25ab71efc223a418e9630d8421f44bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ab71efc223a418e9630d8421f44bc9">&#9670;&nbsp;</a></span>decodeJVC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeJVC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a7c28467832e7480864a6be0ce87c608f">kJvcBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied JVC message. Status: Stable / Known working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>JVC repeat codes don't have a header. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.sbprojects.com/knowledge/ir/jvc.php">http://www.sbprojects.com/knowledge/ir/jvc.php</a> </dd></dl>

</div>
</div>
<a id="a0ac82f20b48b2d71ee07eb392578b226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac82f20b48b2d71ee07eb392578b226">&#9670;&nbsp;</a></span>decodeKelvinator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeKelvinator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#acfa71cb3caf4964829bb1f557dee5b86">kKelvinatorBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Kelvinator message. Status: STABLE / Known working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="ae4af614a45ea65cb3304ef5bd7965122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4af614a45ea65cb3304ef5bd7965122">&#9670;&nbsp;</a></span>decodeLasertag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeLasertag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a3ea0e89a8b6a3ffa4a2d346abeed851e">kLasertagBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Lasertag message. Status: BETA / Appears to be working 90% of the time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This protocol is pretty much just raw Manchester encoding. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.sbprojects.com/knowledge/ir/rc5.php">http://www.sbprojects.com/knowledge/ir/rc5.php</a> </dd>
<dd>
<a href="https://en.wikipedia.org/wiki/RC-5">https://en.wikipedia.org/wiki/RC-5</a> </dd>
<dd>
<a href="https://en.wikipedia.org/wiki/Manchester_code">https://en.wikipedia.org/wiki/Manchester_code</a> </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Convert to using <code><a class="el" href="classIRrecv.html#ade70777ad0e047e11b99b03d8f5e3728" title="Match &amp; decode a Manchester Code &lt;= 64bit IR message. The data is stored at result_ptr.">matchManchester()</a></code> if we can. </dd></dl>

</div>
</div>
<a id="aea75ad0ba1d8fec33de16501940f2553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea75ad0ba1d8fec33de16501940f2553">&#9670;&nbsp;</a></span>decodeLegoPf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeLegoPf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a8a7c7659250a81c7c84fc739eafed13e">kLegoPfBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied LEGO Power Functions message. Status: STABLE / Appears to work. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="afe70015c36b1477a5de0c193163e13a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe70015c36b1477a5de0c193163e13a7">&#9670;&nbsp;</a></span>decodeLG()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeLG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a256bd6093034b3e4c33324680f3a7102">kLgBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied LG message. Status: STABLE / Working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. Typically kLgBits or kLg32Bits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>LG protocol has a repeat code which is 4 items long. Even though the protocol has 28/32 bits of data, only 24/28 bits are distinct. In transmission order, the 28/32 bits are constructed as follows: 8/12 bits of address + 16 bits of command + 4 bits of checksum. </dd>
<dd>
LG 32bit protocol appears near identical to the Samsung protocol. They possibly differ on how they repeat and initial HDR mark. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://funembedded.wordpress.com/2014/11/08/ir-remote-control-for-lg-conditioner-using-stm32f302-mcu-on-mbed-platform/">https://funembedded.wordpress.com/2014/11/08/ir-remote-control-for-lg-conditioner-using-stm32f302-mcu-on-mbed-platform/</a> </dd></dl>

</div>
</div>
<a id="a6093c4404a9a9d415c5bfeab5ec53be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6093c4404a9a9d415c5bfeab5ec53be5">&#9670;&nbsp;</a></span>decodeLutron()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeLutron </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a814dfab515b91887c494237b1f6ebd99">kLutronBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Lutron message. Status: STABLE / Working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a6f3bfcc6767484151dee758bcf94fb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3bfcc6767484151dee758bcf94fb0b">&#9670;&nbsp;</a></span>decodeMagiQuest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeMagiQuest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#ad756bfec6eabbe2ac10b7847f87fb751">kMagiquestBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied MagiQuest message. Status: Beta / Should work. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>MagiQuest protocol appears to be a header of 8 'zero' bits, followed by 32 bits of "wand ID" and finally 16 bits of "magnitude". Even though we describe this protocol as 56 bits, it really only has 48 bits of data that matter. In transmission order, 8 zeros + 32 wand_id + 16 magnitude. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/kitlaan/Arduino-IRremote/blob/master/ir_Magiquest.cpp">https://github.com/kitlaan/Arduino-IRremote/blob/master/ir_Magiquest.cpp</a> </dd></dl>

</div>
</div>
<a id="a255b15601f7439a09ab5e77ad78816fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255b15601f7439a09ab5e77ad78816fb">&#9670;&nbsp;</a></span>decodeMidea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeMidea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#afc98096b1e2945e2eaeb07d70d511239">kMideaBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Midea message. Status: Alpha / Needs testing against a real device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. Typically kHitachiAcBits, kHitachiAc1Bits, kHitachiAc2Bits, kHitachiAc344Bits </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62a04019308b29ae2aea4b3a83ba9155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a04019308b29ae2aea4b3a83ba9155">&#9670;&nbsp;</a></span>decodeMidea24()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeMidea24 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#aff132faa67b1d07890378df5c9b52a14">kMidea24Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Midea24 message. Status: STABLE / Confirmed working on a real device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This protocol is basically a 48-bit version of the NEC protocol with alternate bytes inverted, thus only 24 bits of real data. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Can't be used beyond 32 bits. </dd></dl>

</div>
</div>
<a id="a6efe3be80f0ebef3ff94ed0e56c5c52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6efe3be80f0ebef3ff94ed0e56c5c52a">&#9670;&nbsp;</a></span>decodeMitsubishi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeMitsubishi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#abd2187340d0b94996136081413e2ad22">kMitsubishiBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Mitsubishi 16-bit message. Status: STABLE / Working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This protocol appears to have no header. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>GlobalCache's Control Tower's Mitsubishi TV data. </dd></dl>

</div>
</div>
<a id="ae0690ff3cb5a5cdcdb6a514bb7bf0cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0690ff3cb5a5cdcdb6a514bb7bf0cdd">&#9670;&nbsp;</a></span>decodeMitsubishi112()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeMitsubishi112 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#ae8349abe183be965e3d051cb736773a8">kMitsubishi112Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Mitsubishi/TCL 112-bit A/C message. (MITSUBISHI112, TCL112AC) Status: STABLE / Reported as working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Note Mitsubishi112 &amp; Tcl112Ac are basically the same protocol. The only significant difference I can see is Mitsubishi112 has a slightly longer header mark. We will use that to determine which variant it should be. The other differences require full decoding and only only with certain settings. There are some other timing differences too, but the tolerances will overlap. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/619">https://github.com/crankyoldgit/IRremoteESP8266/issues/619</a> </dd>
<dd>
<a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/947">https://github.com/crankyoldgit/IRremoteESP8266/issues/947</a> </dd></dl>

</div>
</div>
<a id="a87b3ee57dbdf762a0e305ddd43eec629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b3ee57dbdf762a0e305ddd43eec629">&#9670;&nbsp;</a></span>decodeMitsubishi136()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeMitsubishi136 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#aa19f0122b2f906e5473a6ea232c38974">kMitsubishi136Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Mitsubishi 136-bit A/C message. (MITSUBISHI136) Status: STABLE / Reported as working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/888">https://github.com/crankyoldgit/IRremoteESP8266/issues/888</a> </dd></dl>

</div>
</div>
<a id="a9514197850491a5b8c30ae9ffc89d895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9514197850491a5b8c30ae9ffc89d895">&#9670;&nbsp;</a></span>decodeMitsubishi2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeMitsubishi2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#abd2187340d0b94996136081413e2ad22">kMitsubishiBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied second variation of a Mitsubishi 16-bit message. Status: STABLE / Working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/441">https://github.com/crankyoldgit/IRremoteESP8266/issues/441</a> </dd></dl>

</div>
</div>
<a id="a942c5f41df5cbff32a8b7703673cb621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942c5f41df5cbff32a8b7703673cb621">&#9670;&nbsp;</a></span>decodeMitsubishiAC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeMitsubishiAC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a911a47148656b26da2e094a7ced1fc8b">kMitsubishiACBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Mitsubish 144-bit A/C message. Status: BETA / Probably works. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.analysir.com/blog/2015/01/06/reverse-engineering-mitsubishi-ac-infrared-protocol/">https://www.analysir.com/blog/2015/01/06/reverse-engineering-mitsubishi-ac-infrared-protocol/</a> </dd></dl>

</div>
</div>
<a id="aef9cedf79793806df4cc5376710781bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9cedf79793806df4cc5376710781bc">&#9670;&nbsp;</a></span>decodeMitsubishiHeavy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeMitsubishiHeavy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#ab973b35583dabc7e04b12018fac04cc9">kMitsubishiHeavy152Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Mitsubishi Heavy Industries A/C message. Status: BETA / Appears to be working. Needs testing against a real device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. Typically kMitsubishiHeavy88Bits or kMitsubishiHeavy152Bits (def). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="af61afacc9865232643164ba824e665ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61afacc9865232643164ba824e665ab">&#9670;&nbsp;</a></span>decodeMultibrackets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeMultibrackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#aad7be0971479839493615cafcd654fc1">kMultibracketsBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the Multibrackets message. Status: BETA / Appears to be working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a27518b5d792cdf3ab333b324f409f328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27518b5d792cdf3ab333b324f409f328">&#9670;&nbsp;</a></span>decodeMWM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeMWM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code>24</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied MWM message. Status: Implemented. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This protocol is 2400 bps serial, 1 start bit (mark), 1 stop bit (space), no parity </dd></dl>

</div>
</div>
<a id="a52b844f80df7f64edf9ce9cc189ac5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b844f80df7f64edf9ce9cc189ac5b9">&#9670;&nbsp;</a></span>decodeNEC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeNEC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a65e03baf646815b4b02f943bdd74a097">kNECBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied NEC (Renesas) message. Status: STABLE / Known good. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>NEC protocol has three variants/forms. Normal: an 8 bit address &amp; an 8 bit command in 32 bit data form. i.e. address + inverted(address) + command + inverted(command) Extended: a 16 bit address &amp; an 8 bit command in 32 bit data form. i.e. address + command + inverted(command) Repeat: a 0-bit code. i.e. No data bits. Just the header + footer. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.sbprojects.com/knowledge/ir/nec.php">http://www.sbprojects.com/knowledge/ir/nec.php</a> </dd></dl>

</div>
</div>
<a id="a4729ee949e533448b481ae33bbbf1adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4729ee949e533448b481ae33bbbf1adf">&#9670;&nbsp;</a></span>decodeNeoclima()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeNeoclima </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#afff9132e57296b4d7e04ec9e1e5ab04f">kNeoclimaBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Neoclima message. Status: STABLE / Known working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="abbcbf5fc07d7e37d7724acc37bb5f592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcbf5fc07d7e37d7724acc37bb5f592">&#9670;&nbsp;</a></span>decodeNikai()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeNikai </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a9fce002592f9e2488b1b717d0b1a6a40">kNikaiBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Nikai message. Status: STABLE / Working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8dd5f24d28576c6db03cc463bd0a865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8dd5f24d28576c6db03cc463bd0a865">&#9670;&nbsp;</a></span>decodePanasonic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodePanasonic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#aa148f54492be1cf8a8b285a96861a0b7">kPanasonicBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>manufacturer</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a1dd1a9799e5d20d39e82ff678bf07b47">kPanasonicManufacturer</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Panasonic message. Status: STABLE / Should be working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">manufacturer</td><td>A 16-bit manufacturer code. e.g. 0x4004 is Panasonic </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Results to be used with <code>sendPanasonic64()</code>, not <code>sendPanasonic()</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Panasonic 48-bit protocol is a modified version of Kaseikyo. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.remotecentral.com/cgi-bin/mboard/rc-pronto/thread.cgi?2615">http://www.remotecentral.com/cgi-bin/mboard/rc-pronto/thread.cgi?2615</a> </dd>
<dd>
<a href="http://www.hifi-remote.com/wiki/index.php?title=Panasonic">http://www.hifi-remote.com/wiki/index.php?title=Panasonic</a> </dd></dl>

</div>
</div>
<a id="a0f78e180ed731e8fb16d1c85aa721c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f78e180ed731e8fb16d1c85aa721c95">&#9670;&nbsp;</a></span>decodePanasonicAC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodePanasonicAC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a210f5c78b0f90b64dd5037698141433a">kPanasonicAcBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Panasonic AC message. Status: STABLE / Works with real device(s). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a78a9487cbe8a562392a07a4090b3091e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a9487cbe8a562392a07a4090b3091e">&#9670;&nbsp;</a></span>decodePioneer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodePioneer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a6a7ccd31e0a6f967a219b1a53b89653b">kPioneerBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Pioneer message. Status: STABLE / Should be working. (Self decodes &amp; real examples) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="adab9dffbeceee514520fababd0e721bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab9dffbeceee514520fababd0e721bd">&#9670;&nbsp;</a></span>decodeRC5()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeRC5 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#abec3ebb217126560e824fa8b66d495bc">kRC5XBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied RC-5/RC5X message. Status: RC-5 (stable), RC-5X (alpha) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The 'toggle' bit is included as the 6th (MSB) address bit, the MSB of data, &amp; in the count of bits decoded. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Serious testing of the RC-5X and strict aspects needs to be done. </dd></dl>

</div>
</div>
<a id="a67316499ef37db82e3b3ecaac25c5980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67316499ef37db82e3b3ecaac25c5980">&#9670;&nbsp;</a></span>decodeRC6()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeRC6 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a84a6d3e15e98f7a4917d252d5665534a">kRC6Mode0Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied RC6 message. Status: Stable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Testing of the strict compliance aspects. </dd></dl>

</div>
</div>
<a id="a0e7bf769cb5bebf174e852e4b0b08cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7bf769cb5bebf174e852e4b0b08cf3">&#9670;&nbsp;</a></span>decodeRCMM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeRCMM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a2bfaf393c2d77a594f2a0a5a763e84f5">kRCMMBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode a Philips RC-MM packet (between 12 &amp; 32 bits) if possible. Status: STABLE / Should be working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a18b6cf177364faf11b9a076dd2025eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b6cf177364faf11b9a076dd2025eec">&#9670;&nbsp;</a></span>decodeSAMSUNG()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeSAMSUNG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a7c1c015cce09284799cbf5a2f21ee170">kSamsungBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Samsung 32-bit message. Status: STABLE. </p>
<dl class="section note"><dt>Note</dt><dd>Samsung messages whilst 32 bits in size, only contain 16 bits of distinct data. e.g. In transmition order: customer_byte + customer_byte(same) + address_byte + invert(address_byte) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>LG 32bit protocol appears near identical to the Samsung protocol. They differ on their compliance criteria and how they repeat. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://elektrolab.wz.cz/katalog/samsung_protocol.pdf">http://elektrolab.wz.cz/katalog/samsung_protocol.pdf</a> </dd></dl>

</div>
</div>
<a id="a290a9e6a0b12ef1fe02a92a456c8ad57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290a9e6a0b12ef1fe02a92a456c8ad57">&#9670;&nbsp;</a></span>decodeSamsung36()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeSamsung36 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a5e1e6f30a41f0d94652429a9e1034179">kSamsung36Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Samsung36 message. Status: Alpha / Experimental. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/621">https://github.com/crankyoldgit/IRremoteESP8266/issues/621</a> </dd></dl>

</div>
</div>
<a id="ae779c76ebd0f3cd1fc13abaa55f80d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae779c76ebd0f3cd1fc13abaa55f80d67">&#9670;&nbsp;</a></span>decodeSamsungAC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeSamsungAC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#adebe85ab48eb876ec15daacca246797c">kSamsungAcBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Samsung A/C message. Status: Stable / Known to be working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/505">https://github.com/crankyoldgit/IRremoteESP8266/issues/505</a> </dd></dl>

</div>
</div>
<a id="a201a5a78f43c2ac216fae4a2ba4d14ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201a5a78f43c2ac216fae4a2ba4d14ec">&#9670;&nbsp;</a></span>decodeSanyoLC7461()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeSanyoLC7461 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#ad067db05b273337e0df38d529094c9e8">kSanyoLC7461Bits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied SANYO LC7461 message. Status: BETA / Probably works. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Based on @marcosamarinho's work. This protocol uses the NEC protocol. However, data is formatted as : address(13 bits), !address, command (8 bits), !command. According with LIRC, this protocol is used on Sanyo, Aiwa and Chinon Information for this protocol is available at the Sanyo LC7461 datasheet. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://slydiman.narod.ru/scr/kb/sanyo.htm">http://slydiman.narod.ru/scr/kb/sanyo.htm</a> </dd>
<dd>
<a href="https://github.com/marcosamarinho/IRremoteESP8266/blob/master/ir_Sanyo.cpp">https://github.com/marcosamarinho/IRremoteESP8266/blob/master/ir_Sanyo.cpp</a> </dd>
<dd>
<a href="http://pdf.datasheetcatalog.com/datasheet/sanyo/LC7461.pdf">http://pdf.datasheetcatalog.com/datasheet/sanyo/LC7461.pdf</a> </dd></dl>

</div>
</div>
<a id="a3390d63ba21a835d7c74c261532a22a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3390d63ba21a835d7c74c261532a22a7">&#9670;&nbsp;</a></span>decodeSharp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeSharp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a8a74f9d7cec751cc0945fd89fa6237ae">kSharpBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>expansion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Sharp message. Status: STABLE / Working fine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expansion</td><td>Should we expect the expansion bit to be set. Default is true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This procedure returns a value suitable for use in <code>sendSharpRaw()</code>. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Need to ensure capture of the inverted message as it can be missed due to the interrupt timeout used to detect an end of message. Several compliance checks are disabled until that is resolved. </dd></dl>

</div>
</div>
<a id="a8a9b920079f783e236f8a938e20b9743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9b920079f783e236f8a938e20b9743">&#9670;&nbsp;</a></span>decodeSharpAc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeSharpAc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a6c106a982acced5d8aeef98644002ca2">kSharpAcBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Sharp A/C message. Status: STABLE / Known working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/crankyoldgit/IRremoteESP8266/issues/638">https://github.com/crankyoldgit/IRremoteESP8266/issues/638</a> </dd>
<dd>
<a href="https://github.com/ToniA/arduino-heatpumpir/blob/master/SharpHeatpumpIR.cpp">https://github.com/ToniA/arduino-heatpumpir/blob/master/SharpHeatpumpIR.cpp</a> </dd></dl>

</div>
</div>
<a id="ab03227955cf7d1d00c1620c55d7f9f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03227955cf7d1d00c1620c55d7f9f18">&#9670;&nbsp;</a></span>decodeSony()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeSony </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a6f0794107a7643e0bec8de6de9e7621b">kSonyMinBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Sony/SIRC message. Status: STABLE / Should be working. strict mode is ALPHA / Untested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>SONY protocol, SIRC (Serial Infra-Red Control) can be 12, 15, or 20 bits long. </dd></dl>

</div>
</div>
<a id="a61cdf4d891654521afbc6ca9fb415745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61cdf4d891654521afbc6ca9fb415745">&#9670;&nbsp;</a></span>decodeSymphony()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeSymphony </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#abb5b89578ab0757999530c0383f38533">kSymphonyBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Symphony packet/message. Status: STABLE / Should be working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a950711d7df8dfe4cda86f53650cd9f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950711d7df8dfe4cda86f53650cd9f56">&#9670;&nbsp;</a></span>decodeTeco()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeTeco </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#aee01958e9d97a70a6881cf560ca0ca9d">kTecoBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Teco message. Status: STABLE / Tested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a01228e51ede905beac689967bb14b538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01228e51ede905beac689967bb14b538">&#9670;&nbsp;</a></span>decodeToshibaAC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeToshibaAC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a172dde7867fa9a68902c3ad7ea9629b0">kToshibaACBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Toshiba A/C message. Status: STABLE / Working. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="ae2920c488173f3fa37f5325438157ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2920c488173f3fa37f5325438157ced">&#9670;&nbsp;</a></span>decodeTrotec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeTrotec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#ab819cb0a34937714dcb10059799c26e2">kTrotecBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Trotec message. Status: STABLE / Works. Untested on real devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a5d48b3c91434c18c7726cca504d75b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d48b3c91434c18c7726cca504d75b73">&#9670;&nbsp;</a></span>decodeVestelAc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeVestelAc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#ae31945a1ce90b2d4c33b5c91d980d3a7">kVestelAcBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Vestel message. Status: Alpha / Needs testing against a real device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a0d1eec83cf092f5621cb34b3e94777c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1eec83cf092f5621cb34b3e94777c4">&#9670;&nbsp;</a></span>decodeWhirlpoolAC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeWhirlpoolAC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a149bd4f3fb9c83e683095d393209ede3">kWhirlpoolAcBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Whirlpool A/C message. Status: STABLE / Working as intended. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a66289f6a462557ad26e6c0a64f36cf02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66289f6a462557ad26e6c0a64f36cf02">&#9670;&nbsp;</a></span>decodeWhynter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeWhynter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#a4553f6670e241a67104d45216a4ebd98">kWhynterBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Whynter message. Status: STABLE / Working. Strict mode is ALPHA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it can decode it, false if it can't. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/z3t0/Arduino-IRremote/blob/master/ir_Whynter.cpp">https://github.com/z3t0/Arduino-IRremote/blob/master/ir_Whynter.cpp</a> </dd></dl>

</div>
</div>
<a id="a72afd857c8b2e0192021a40afc96c2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72afd857c8b2e0192021a40afc96c2d8">&#9670;&nbsp;</a></span>decodeZepeal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::decodeZepeal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="IRrecv_8h.html#a44a836a34428f8f75b1ae566de4bb972">kStartOffset</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em> = <code><a class="el" href="IRremoteESP8266_8h.html#af09c9402a1c4fa24f692994498641296">kZepealBits</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the supplied Zepeal message. Status: STABLE / Works on real device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode &amp; where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The starting index to use when attempting to decode the raw data. Typically/Defaults to kStartOffset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>The number of data bits to expect. Typically kZepealBits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict</td><td>Flag indicating if we should perform strict matching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. True if it can decode it, false if it can't. </dd></dl>

</div>
</div>
<a id="a9f4a719e756ad78c7dd47186f8bef087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4a719e756ad78c7dd47186f8bef087">&#9670;&nbsp;</a></span>disableIRIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::disableIRIn </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop collection of any received IR data. Disable any timers and interrupts. </p>

</div>
</div>
<a id="a52c05ec6d8f3dbfb75f21f3b4fe7be3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c05ec6d8f3dbfb75f21f3b4fe7be3d">&#9670;&nbsp;</a></span>enableIRIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::enableIRIn </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>pullup</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up and (re)start the IR capture mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pullup</td><td>A flag indicating should the GPIO use the internal pullup resistor. (Default: <code>false</code>. i.e. No.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69ab02ea6823ccf18d1f6be87ca1b92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ab02ea6823ccf18d1f6be87ca1b92e">&#9670;&nbsp;</a></span>getBufSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t IRrecv::getBufSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the maximum number of entries possible in the capture buffer. i.e. It's size. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the buffer that is in use by the object. </dd></dl>

</div>
</div>
<a id="a8e32daaa903a8e42dad7faaf405b33dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e32daaa903a8e42dad7faaf405b33dc">&#9670;&nbsp;</a></span>getRClevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t IRrecv::getRClevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdecode__results.html">decode_results</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>used</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bitTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>excess</em> = <code><a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>delta</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>maxwidth</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets one undecoded level at a time from the raw buffer. The RC5/6 decoding is easier if the data is broken into time intervals. E.g. if the buffer has MARK for 2 time intervals and SPACE for 1, successive calls to getRClevel will return MARK, MARK, SPACE. offset and used are updated to keep track of the current position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">results</td><td>Ptr to the data to decode and where to store the decode result. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">offset</td><td>Ptr to the currect offset to the rawbuf. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">used</td><td>Ptr to the current used counter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bitTime</td><td>Time interval of single bit in microseconds. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>Percent tolerance to be used in matching. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">excess</td><td>Extra useconds to add to Marks &amp; removed from Spaces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>A non-scaling (+/-) error margin (in useconds). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxwidth</td><td>Maximum number of successive levels to find in a single level (default is 3) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MARK, SPACE, or -1 for error. (The measured time interval is not a multiple of t1.) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Manchester_code">https://en.wikipedia.org/wiki/Manchester_code</a> </dd></dl>

</div>
</div>
<a id="a144f64da3b44708394c06b0fbefb6347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144f64da3b44708394c06b0fbefb6347">&#9670;&nbsp;</a></span>getTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t IRrecv::getTolerance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the base tolerance percentage for matching incoming IR messages. </p>
<dl class="section return"><dt>Returns</dt><dd>A integer percentage. </dd></dl>

</div>
</div>
<a id="a8bc218dae714ab189a3da4fff269cdaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc218dae714ab189a3da4fff269cdaa">&#9670;&nbsp;</a></span>match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::match </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>measured</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>delta</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if we match a pulse(measured) with the desired within +/-tolerance percent and/or +/- a fixed delta range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">measured</td><td>The recorded period of the signal pulse. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desired</td><td>The expected period (in usecs) we are matching against. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>A percentage expressed as an integer. e.g. 10 is 10%. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>A non-scaling (+/-) error margin (in useconds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Boolean. true if it matches, false if it doesn't. </dd></dl>

</div>
</div>
<a id="ae7bfd4ff689c7563c65c4e6e8c58187a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bfd4ff689c7563c65c4e6e8c58187a">&#9670;&nbsp;</a></span>matchAtLeast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::matchAtLeast </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>measured</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>delta</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if we match a pulse(measured) of at least desired within tolerance percent and/or a fixed delta margin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">measured</td><td>The recorded period of the signal pulse. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desired</td><td>The expected period (in usecs) we are matching against. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>A percentage expressed as an integer. e.g. 10 is 10%. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>A non-scaling amount to reduce usecs by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Boolean. true if it matches, false if it doesn't. </dd></dl>

</div>
</div>
<a id="adc2c9bc4c4e5741cfac7468126bf8ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2c9bc4c4e5741cfac7468126bf8ca6">&#9670;&nbsp;</a></span>matchBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t IRrecv::matchBytes </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>result_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>remaining</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>onemark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>onespace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>zeromark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>zerospace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>excess</em> = <code><a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>MSBfirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match &amp; decode the typical data section of an IR message. The bytes are stored at result_ptr. The first byte in the result equates to the first byte encountered, and so on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_ptr</td><td>A pointer to where we are at in the capture buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_ptr</td><td>A ptr to where to start storing the bytes we decoded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remaining</td><td>The size of the capture buffer remaining. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbytes</td><td>Nr. of data bytes we expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onemark</td><td>Nr. of uSeconds in an expected mark signal for a '1' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onespace</td><td>Nr. of uSecs in an expected space signal for a '1' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zeromark</td><td>Nr. of uSecs in an expected mark signal for a '0' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zerospace</td><td>Nr. of uSecs in an expected space signal for a '0' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>Percentage error margin to allow. (Default: kUseDefTol) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">excess</td><td>Nr. of uSeconds. (Def: kMarkExcess) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MSBfirst</td><td>Bit order to save the data in. (Def: true) true is Most Significant Bit First Order, false is Least Significant First </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, how many buffer entries were used. Otherwise 0. </dd></dl>

</div>
</div>
<a id="a5361439cb69b1069553544e486502d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5361439cb69b1069553544e486502d2e">&#9670;&nbsp;</a></span>matchData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatch__result__t.html">match_result_t</a> IRrecv::matchData </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>onemark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>onespace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>zeromark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>zerospace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>excess</em> = <code><a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>MSBfirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match &amp; decode the typical data section of an IR message. The data value is stored in the least significant bits reguardless of the bit ordering requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_ptr</td><td>A pointer to where we are at in the capture buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>Nr. of data bits we expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onemark</td><td>Nr. of uSeconds in an expected mark signal for a '1' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onespace</td><td>Nr. of uSecs in an expected space signal for a '1' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zeromark</td><td>Nr. of uSecs in an expected mark signal for a '0' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zerospace</td><td>Nr. of uSecs in an expected space signal for a '0' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>Percentage error margin to allow. (Default: kUseDefTol) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">excess</td><td>Nr. of uSeconds. (Def: kMarkExcess) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MSBfirst</td><td>Bit order to save the data in. (Def: true) true is Most Significant Bit First Order, false is Least Significant First </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structmatch__result__t.html" title="Results from a data match.">match_result_t</a> structure containing the success (or not), the data value, and how many buffer entries were used. </dd></dl>

</div>
</div>
<a id="ab783f52acc2ff4052313d6947563e4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab783f52acc2ff4052313d6947563e4fd">&#9670;&nbsp;</a></span>matchGeneric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t IRrecv::matchGeneric </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>remaining</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>hdrmark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>hdrspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>onemark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>onespace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>zeromark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>zerospace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>footermark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>footerspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>atleast</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>excess</em> = <code><a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>MSBfirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match &amp; decode a generic/typical &lt;= 64bit IR message. The data is stored at result_ptr. </p>
<dl class="section note"><dt>Note</dt><dd>Values of 0 for hdrmark, hdrspace, footermark, or footerspace mean skip that requirement.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_ptr</td><td>A pointer to where we are at in the capture buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_ptr</td><td>A ptr to where to start storing the bits we decoded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remaining</td><td>The size of the capture buffer remaining. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>Nr. of data bits we expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hdrmark</td><td>Nr. of uSeconds for the expected header mark signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hdrspace</td><td>Nr. of uSeconds for the expected header space signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onemark</td><td>Nr. of uSeconds in an expected mark signal for a '1' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onespace</td><td>Nr. of uSecs in an expected space signal for a '1' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zeromark</td><td>Nr. of uSecs in an expected mark signal for a '0' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zerospace</td><td>Nr. of uSecs in an expected space signal for a '0' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">footermark</td><td>Nr. of uSeconds for the expected footer mark signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">footerspace</td><td>Nr. of uSeconds for the expected footer space/gap signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">atleast</td><td>Is the match on the footerspace a matchAtLeast or matchSpace? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>Percentage error margin to allow. (Default: kUseDefTol) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">excess</td><td>Nr. of uSeconds. (Def: kMarkExcess) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MSBfirst</td><td>Bit order to save the data in. (Def: true) true is Most Significant Bit First Order, false is Least Significant First </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, how many buffer entries were used. Otherwise 0. </dd></dl>

</div>
</div>
<a id="a4448c1658383962d735353352987c9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4448c1658383962d735353352987c9aa">&#9670;&nbsp;</a></span>matchGeneric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t IRrecv::matchGeneric </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>result_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>remaining</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>hdrmark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>hdrspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>onemark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>onespace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>zeromark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>zerospace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>footermark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>footerspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>atleast</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>excess</em> = <code><a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>MSBfirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match &amp; decode a generic/typical &gt; 64bit IR message. The bytes are stored at result_ptr. The first byte in the result equates to the first byte encountered, and so on. </p>
<dl class="section note"><dt>Note</dt><dd>Values of 0 for hdrmark, hdrspace, footermark, or footerspace mean skip that requirement. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_ptr</td><td>A pointer to where we are at in the capture buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_ptr</td><td>A ptr to where to start storing the bytes we decoded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remaining</td><td>The size of the capture buffer remaining. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>Nr. of data bits we expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hdrmark</td><td>Nr. of uSeconds for the expected header mark signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hdrspace</td><td>Nr. of uSeconds for the expected header space signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onemark</td><td>Nr. of uSeconds in an expected mark signal for a '1' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onespace</td><td>Nr. of uSecs in an expected space signal for a '1' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zeromark</td><td>Nr. of uSecs in an expected mark signal for a '0' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zerospace</td><td>Nr. of uSecs in an expected space signal for a '0' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">footermark</td><td>Nr. of uSeconds for the expected footer mark signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">footerspace</td><td>Nr. of uSeconds for the expected footer space/gap signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">atleast</td><td>Is the match on the footerspace a matchAtLeast or matchSpace? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>Percentage error margin to allow. (Default: kUseDefTol) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">excess</td><td>Nr. of uSeconds. (Def: kMarkExcess) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MSBfirst</td><td>Bit order to save the data in. (Def: true) true is Most Significant Bit First Order, false is Least Significant First </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, how many buffer entries were used. Otherwise 0. </dd></dl>

</div>
</div>
<a id="a4582d75ef1d11aee35fce86c38dcccf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4582d75ef1d11aee35fce86c38dcccf0">&#9670;&nbsp;</a></span>matchGenericConstBitTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t IRrecv::matchGenericConstBitTime </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>remaining</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>hdrmark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>hdrspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>footermark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>footerspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>atleast</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>excess</em> = <code><a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>MSBfirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match &amp; decode a generic/typical constant bit time &lt;= 64bit IR message. The data is stored at result_ptr. </p>
<dl class="section note"><dt>Note</dt><dd>Values of 0 for hdrmark, hdrspace, footermark, or footerspace mean skip that requirement. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_ptr</td><td>A pointer to where we are at in the capture buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>data_ptr</code> is assumed to be pointing to a "Mark", not a "Space". </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result_ptr</td><td>A ptr to where to start storing the bits we decoded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remaining</td><td>The size of the capture buffer remaining. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>Nr. of data bits we expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hdrmark</td><td>Nr. of uSeconds for the expected header mark signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hdrspace</td><td>Nr. of uSeconds for the expected header space signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">one</td><td>Nr. of uSeconds in an expected mark signal for a '1' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zero</td><td>Nr. of uSeconds in an expected mark signal for a '0' bit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">footermark</td><td>Nr. of uSeconds for the expected footer mark signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">footerspace</td><td>Nr. of uSeconds for the expected footer space/gap signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">atleast</td><td>Is the match on the footerspace a matchAtLeast or matchSpace? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>Percentage error margin to allow. (Default: kUseDefTol) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">excess</td><td>Nr. of uSeconds. (Def: kMarkExcess) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MSBfirst</td><td>Bit order to save the data in. (Def: true) true is Most Significant Bit First Order, false is Least Significant First </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, how many buffer entries were used. Otherwise 0. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Parameters one + zero add up to the total time for a bit. e.g. mark(one) + space(zero) is a <code>1</code>, mark(zero) + space(one) is a <code>0</code>. </dd></dl>

</div>
</div>
<a id="ade70777ad0e047e11b99b03d8f5e3728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade70777ad0e047e11b99b03d8f5e3728">&#9670;&nbsp;</a></span>matchManchester()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t IRrecv::matchManchester </td>
          <td>(</td>
          <td class="paramtype">volatile const uint16_t *&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>remaining</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>hdrmark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>hdrspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>half_period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>footermark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>footerspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>atleast</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>excess</em> = <code><a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>MSBfirst</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>GEThomas</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match &amp; decode a Manchester Code &lt;= 64bit IR message. The data is stored at result_ptr. </p>
<dl class="section note"><dt>Note</dt><dd>Values of 0 for hdrmark, hdrspace, footermark, or footerspace mean skip that requirement. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_ptr</td><td>A pointer to where we are at in the capture buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>data_ptr</code> is assumed to be pointing to a "Mark", not a "Space". </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result_ptr</td><td>A ptr to where to start storing the bits we decoded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remaining</td><td>The size of the capture buffer remaining. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>Nr. of data bits we expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hdrmark</td><td>Nr. of uSeconds for the expected header mark signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hdrspace</td><td>Nr. of uSeconds for the expected header space signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">half_period</td><td>Nr. of uSeconds for half the clock's period. i.e. 1/2 wavelength </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">footermark</td><td>Nr. of uSeconds for the expected footer mark signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">footerspace</td><td>Nr. of uSeconds for the expected footer space/gap signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">atleast</td><td>Is the match on the footerspace a matchAtLeast or matchSpace? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>Percentage error margin to allow. (Default: kUseDefTol) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">excess</td><td>Nr. of uSeconds. (Def: kMarkExcess) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MSBfirst</td><td>Bit order to save the data in. (Def: true) true is Most Significant Bit First Order, false is Least Significant First </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GEThomas</td><td>Use G.E. Thomas (true) or IEEE 802.3 (false) convention? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, how many buffer entries were used. Otherwise 0. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Manchester_code">https://en.wikipedia.org/wiki/Manchester_code</a> </dd>
<dd>
<a href="http://ww1.microchip.com/downloads/en/AppNotes/Atmel-9164-Manchester-Coding-Basics_Application-Note.pdf">http://ww1.microchip.com/downloads/en/AppNotes/Atmel-9164-Manchester-Coding-Basics_Application-Note.pdf</a> </dd></dl>

</div>
</div>
<a id="ab44403411a217eb8ea75271575f8ab83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44403411a217eb8ea75271575f8ab83">&#9670;&nbsp;</a></span>matchManchesterData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t IRrecv::matchManchesterData </td>
          <td>(</td>
          <td class="paramtype">volatile const uint16_t *&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>remaining</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nbits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>half_period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>starting_balance</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>excess</em> = <code><a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>MSBfirst</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>GEThomas</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match &amp; decode a Manchester Code data (&lt;= 64bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_ptr</td><td>A pointer to where we are at in the capture buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>data_ptr</code> is assumed to be pointing to a "Mark", not a "Space". </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result_ptr</td><td>A ptr to where to start storing the bits we decoded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remaining</td><td>The size of the capture buffer remaining. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbits</td><td>Nr. of data bits we expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">half_period</td><td>Nr. of uSeconds for half the clock's period. i.e. 1/2 wavelength </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>Percentage error margin to allow. (Default: kUseDefTol) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">starting_balance</td><td>Amount of uSeconds to assume exists prior to the current value pointed too. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">excess</td><td>Nr. of uSeconds. (Def: kMarkExcess) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MSBfirst</td><td>Bit order to save the data in. (Def: true) true is Most Significant Bit First Order, false is Least Significant First </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GEThomas</td><td>Use G.E. Thomas (true) or IEEE 802.3 (false) convention? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, how many buffer entries were used. Otherwise 0. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Manchester_code">https://en.wikipedia.org/wiki/Manchester_code</a> </dd>
<dd>
<a href="http://ww1.microchip.com/downloads/en/AppNotes/Atmel-9164-Manchester-Coding-Basics_Application-Note.pdf">http://ww1.microchip.com/downloads/en/AppNotes/Atmel-9164-Manchester-Coding-Basics_Application-Note.pdf</a> </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Clean up and optimise this. It is just "get it working code" atm. </dd></dl>

</div>
</div>
<a id="ae78ef12b8194db5d3cb5a2605d29830d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78ef12b8194db5d3cb5a2605d29830d">&#9670;&nbsp;</a></span>matchMark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::matchMark </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>measured</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>excess</em> = <code><a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if we match a mark signal(measured) with the desired within +/-tolerance percent, after an expected is excess is added. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">measured</td><td>The recorded period of the signal pulse. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desired</td><td>The expected period (in usecs) we are matching against. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>A percentage expressed as an integer. e.g. 10 is 10%. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">excess</td><td>A non-scaling amount to reduce usecs by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Boolean. true if it matches, false if it doesn't. </dd></dl>

</div>
</div>
<a id="a9fd363e8b2edee2ed3c473349ecc58fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd363e8b2edee2ed3c473349ecc58fc">&#9670;&nbsp;</a></span>matchSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IRrecv::matchSpace </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>measured</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>excess</em> = <code><a class="el" href="IRrecv_8h.html#a99bbffe986ad7ba86d2b11e75f4aa50e">kMarkExcess</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if we match a space signal(measured) with the desired within +/-tolerance percent, after an expected is excess is removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">measured</td><td>The recorded period of the signal pulse. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desired</td><td>The expected period (in usecs) we are matching against. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>A percentage expressed as an integer. e.g. 10 is 10%. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">excess</td><td>A non-scaling amount to reduce usecs by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Boolean. true if it matches, false if it doesn't. </dd></dl>

</div>
</div>
<a id="a6b5beb7348d807d8d98ae929d005510e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5beb7348d807d8d98ae929d005510e">&#9670;&nbsp;</a></span>resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::resume </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume collection of received IR data. </p>
<dl class="section note"><dt>Note</dt><dd>This is required if <code><a class="el" href="classIRrecv.html#aeaa5c07a8b46f8fbb982f996cc1f9f4b" title="Decodes the received IR message. If the interrupt state is saved, we will immediately resume waiting ...">decode()</a></code> is successful and <code>save_buffer</code> was not set when the class was instanciated. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classIRrecv.html" title="Class for receiving IR messages.">IRrecv</a> class constructor </dd></dl>

</div>
</div>
<a id="aa091c449db70c65fd0221669df7438ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa091c449db70c65fd0221669df7438ea">&#9670;&nbsp;</a></span>setTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::setTolerance </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>percent</em> = <code><a class="el" href="IRrecv_8h.html#a7884008b3a738dfc7bd8658655e10272">kTolerance</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the base tolerance percentage for matching incoming IR messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">percent</td><td>An integer percentage. (0-100) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02693553aad1decd67bdae60402e48bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02693553aad1decd67bdae60402e48bf">&#9670;&nbsp;</a></span>setUnknownThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IRrecv::setUnknownThreshold </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimum length we will consider for reporting UNKNOWN message types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Min nr. of mark/space pulses required to be considered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a573dbb20695f2ffc808623df8c36280c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573dbb20695f2ffc808623df8c36280c">&#9670;&nbsp;</a></span>ticksHigh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IRrecv::ticksHigh </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>usecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>delta</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the upper bound of the nr. of ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">usecs</td><td>Nr. of uSeconds. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>Percent as an integer. e.g. 10 is 10% </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>A non-scaling amount to increase usecs by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nr. of ticks. </dd></dl>

</div>
</div>
<a id="ac08e50c5eec10c0095157f4bdd4051c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08e50c5eec10c0095157f4bdd4051c8">&#9670;&nbsp;</a></span>ticksLow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IRrecv::ticksLow </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>usecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="IRrecv_8h.html#a05025e8bd724ae2d0c7fea6e924ca84c">kUseDefTol</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>delta</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the lower bound of the nr. of ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">usecs</td><td>Nr. of uSeconds. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>Percent as an integer. e.g. 10 is 10% </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>A non-scaling amount to reduce usecs by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nr. of ticks. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aff11c0c20735b16ce411088003607911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff11c0c20735b16ce411088003607911">&#9670;&nbsp;</a></span>_timer_num</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t IRrecv::_timer_num</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0459a65dd31b215713ad66a1e4f3540e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0459a65dd31b215713ad66a1e4f3540e">&#9670;&nbsp;</a></span>_tolerance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t IRrecv::_tolerance</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb8cbc5c1cb739f33f5be25b3a6c79bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8cbc5c1cb739f33f5be25b3a6c79bd">&#9670;&nbsp;</a></span>_unknown_threshold</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t IRrecv::_unknown_threshold</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fdac84ce51ce119972bf121ccc95aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdac84ce51ce119972bf121ccc95aab">&#9670;&nbsp;</a></span>irparams_save</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structirparams__t.html">irparams_t</a>* IRrecv::irparams_save</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="IRrecv_8h_source.html">IRrecv.h</a></li>
<li>src/<a class="el" href="ir__Airwell_8cpp.html">ir_Airwell.cpp</a></li>
<li>src/<a class="el" href="ir__Aiwa_8cpp.html">ir_Aiwa.cpp</a></li>
<li>src/<a class="el" href="ir__Amcor_8cpp.html">ir_Amcor.cpp</a></li>
<li>src/<a class="el" href="ir__Argo_8cpp.html">ir_Argo.cpp</a></li>
<li>src/<a class="el" href="ir__Carrier_8cpp.html">ir_Carrier.cpp</a></li>
<li>src/<a class="el" href="ir__Coolix_8cpp.html">ir_Coolix.cpp</a></li>
<li>src/<a class="el" href="ir__Corona_8cpp.html">ir_Corona.cpp</a></li>
<li>src/<a class="el" href="ir__Daikin_8cpp.html">ir_Daikin.cpp</a></li>
<li>src/<a class="el" href="ir__Delonghi_8cpp.html">ir_Delonghi.cpp</a></li>
<li>src/<a class="el" href="ir__Denon_8cpp.html">ir_Denon.cpp</a></li>
<li>src/<a class="el" href="ir__Dish_8cpp.html">ir_Dish.cpp</a></li>
<li>src/<a class="el" href="ir__Doshisha_8cpp.html">ir_Doshisha.cpp</a></li>
<li>src/<a class="el" href="ir__Electra_8cpp.html">ir_Electra.cpp</a></li>
<li>src/<a class="el" href="ir__Epson_8cpp.html">ir_Epson.cpp</a></li>
<li>src/<a class="el" href="ir__Fujitsu_8cpp.html">ir_Fujitsu.cpp</a></li>
<li>src/<a class="el" href="ir__GICable_8cpp.html">ir_GICable.cpp</a></li>
<li>src/<a class="el" href="ir__Goodweather_8cpp.html">ir_Goodweather.cpp</a></li>
<li>src/<a class="el" href="ir__Gree_8cpp.html">ir_Gree.cpp</a></li>
<li>src/<a class="el" href="ir__Haier_8cpp.html">ir_Haier.cpp</a></li>
<li>src/<a class="el" href="ir__Hitachi_8cpp.html">ir_Hitachi.cpp</a></li>
<li>src/<a class="el" href="ir__Inax_8cpp.html">ir_Inax.cpp</a></li>
<li>src/<a class="el" href="ir__JVC_8cpp.html">ir_JVC.cpp</a></li>
<li>src/<a class="el" href="ir__Kelvinator_8cpp.html">ir_Kelvinator.cpp</a></li>
<li>src/<a class="el" href="ir__Lasertag_8cpp.html">ir_Lasertag.cpp</a></li>
<li>src/<a class="el" href="ir__Lego_8cpp.html">ir_Lego.cpp</a></li>
<li>src/<a class="el" href="ir__LG_8cpp.html">ir_LG.cpp</a></li>
<li>src/<a class="el" href="ir__Lutron_8cpp.html">ir_Lutron.cpp</a></li>
<li>src/<a class="el" href="ir__Magiquest_8cpp.html">ir_Magiquest.cpp</a></li>
<li>src/<a class="el" href="ir__Midea_8cpp.html">ir_Midea.cpp</a></li>
<li>src/<a class="el" href="ir__Mitsubishi_8cpp.html">ir_Mitsubishi.cpp</a></li>
<li>src/<a class="el" href="ir__MitsubishiHeavy_8cpp.html">ir_MitsubishiHeavy.cpp</a></li>
<li>src/<a class="el" href="ir__Multibrackets_8cpp.html">ir_Multibrackets.cpp</a></li>
<li>src/<a class="el" href="ir__MWM_8cpp.html">ir_MWM.cpp</a></li>
<li>src/<a class="el" href="ir__NEC_8cpp.html">ir_NEC.cpp</a></li>
<li>src/<a class="el" href="ir__Neoclima_8cpp.html">ir_Neoclima.cpp</a></li>
<li>src/<a class="el" href="ir__Nikai_8cpp.html">ir_Nikai.cpp</a></li>
<li>src/<a class="el" href="ir__Panasonic_8cpp.html">ir_Panasonic.cpp</a></li>
<li>src/<a class="el" href="ir__Pioneer_8cpp.html">ir_Pioneer.cpp</a></li>
<li>src/<a class="el" href="ir__RC5__RC6_8cpp.html">ir_RC5_RC6.cpp</a></li>
<li>src/<a class="el" href="ir__RCMM_8cpp.html">ir_RCMM.cpp</a></li>
<li>src/<a class="el" href="ir__Samsung_8cpp.html">ir_Samsung.cpp</a></li>
<li>src/<a class="el" href="ir__Sanyo_8cpp.html">ir_Sanyo.cpp</a></li>
<li>src/<a class="el" href="ir__Sharp_8cpp.html">ir_Sharp.cpp</a></li>
<li>src/<a class="el" href="ir__Sony_8cpp.html">ir_Sony.cpp</a></li>
<li>src/<a class="el" href="ir__Symphony_8cpp.html">ir_Symphony.cpp</a></li>
<li>src/<a class="el" href="ir__Teco_8cpp.html">ir_Teco.cpp</a></li>
<li>src/<a class="el" href="ir__Toshiba_8cpp.html">ir_Toshiba.cpp</a></li>
<li>src/<a class="el" href="ir__Trotec_8cpp.html">ir_Trotec.cpp</a></li>
<li>src/<a class="el" href="ir__Vestel_8cpp.html">ir_Vestel.cpp</a></li>
<li>src/<a class="el" href="ir__Whirlpool_8cpp.html">ir_Whirlpool.cpp</a></li>
<li>src/<a class="el" href="ir__Whynter_8cpp.html">ir_Whynter.cpp</a></li>
<li>src/<a class="el" href="ir__Zepeal_8cpp.html">ir_Zepeal.cpp</a></li>
<li>src/<a class="el" href="IRrecv_8cpp.html">IRrecv.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
